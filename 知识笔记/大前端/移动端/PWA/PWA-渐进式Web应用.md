# PWA-渐进式Web应用

	Progressive Web Apps

## 概述

#### PWA存在的原因

1. Native app体验确实很好，下载到手机上之后入口也方便。但它也有一些缺点

	* 开发成本高(ios和安卓)
	* 软件上线需要审核
	* 版本更新需要将新版本上传到不同的应用商店
	* 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下

2. web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点

	* 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签
	* 没网络就没响应，不具备离线能力
	* 不像APP一样能进行消息推送

#### PWA简介

	PWA全称Progressive Web App，即渐进式WEB应用。

* 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能

* 它的存在解决了一些问题：

	* 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏
	* 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能
	* 实现了消息推送

> 这些特性将使得 Web 应用渐进式接近原生 App

**PWA特性**

* 渐进增强 - 能够让每一位用户使用，无论用户使用什么浏览器，因为它是始终以渐进增强为原则。

* 响应式用户界面 - 适应任何环境：桌面电脑，智能手机，笔记本电脑，或者其他设备。

* 不依赖网络连接 - 通过 service workers 可以在离线或者网速极差的环境下工作。

* 类原生应用 - 有像原生应用般的交互和导航给用户原生应用般的体验，因为它是建立在 app shell model 上的。

* 持续更新 - 受益于 service worker 的更新进程，应用能够始终保持更新。

* 安全 - 通过 HTTPS 来提供服务来防止网络窥探，保证内容不被篡改。

* 可发现 - 得益于 W3C manifests 元数据和 service worker 的登记，让搜索引擎能够找到 web 应用。

* 再次访问 - 通过消息推送等特性让用户再次访问变得容易。

* 可安装 - 允许用户保留对他们有用的应用在主屏幕上，不需要通过应用商店。

* 可连接性 - 通过 URL 可以轻松分享应用，不用复杂的安装即可运行。

#### PWA的优劣

###### 优势

1. 可以将app的快捷方式放置到桌面上，全屏运行，与原生app无异

2. 能够在各种网络环境下使用，包括网络差和断网条件下，不会显示undefined

3. 推送消息的能力

4. 其本质是一个网页，没有原生app的各种启动条件，快速响应用户指令

###### 存在的问题

1. 支持率不高：现在ios手机端不支持pwa，IE也暂时不支持

2. Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低

3. 各大厂商还未明确支持pwa

4. 依赖的GCM服务在国内无法使用

5. 微信小程序的竞争

###### 亮点

* service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。

* service worker实现消息推送，使用浏览器推送功能，吸引用户

* 渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。

## PWA使用方式

#### Manifest（应用清单）

	Manifest实现添加至主屏幕

**web 应用程序清单**

* 能够真实存在于用户主屏幕上

* 在 Android 上能够全屏启动，不显示地址栏

* 控制屏幕方向已获得最佳效果

* 定义启动画面，为你的站点定义主题

* 追踪你的应用是从主屏幕还是 URL 启动的

#### service worker实现离线缓存

	Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP请求，从而完全控制我们的网站

**主要的特点**

* 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。

* 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)

* 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求

* 单独的作用域范围，单独的运行环境和执行线程

* 不能操作页面 DOM。但可以通过事件机制来处理

* 事件驱动型服务线程

**为什么要求网站必须是HTTPS？**

	因为service worker权限太大能拦截所有页面的请求，如果http的网站安装service worker很容易被攻击

**过程**

	当用户首次导航至 URL 时，服务器会返回响应的网页

1. 当调用 register() 函数时， Service Worker 开始下载。

2. 在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。

3. 一旦 Service Worker 成功执行了，install 事件就会激活

4. 安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用！

###### HTTP缓存与service worker缓存

* HTTP缓存

	* Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。
	* 使用 HTTP 缓存意味着我们要依赖服务器来告诉我们何时缓存资源和何时过期。

* service worker缓存

	* Service Workers 的强大在于它们拦截 HTTP 请求的能力
	* 进入任何传入的 HTTP 请求，并决定想要如何响应。在我们的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归掌控！

#### service worker实现消息推送

* 步骤一、提示用户并获得他们的订阅详细信息

* 步骤二、将这些详细信息保存在服务器上

* 步骤三、在需要时发送任何消息

> 不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<GCM> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。

> 参考：[深蓝一人-讲讲PWA](https://segmentfault.com/a/1190000012353473)
