# 离线应用

## 概述

#### 什么是离线应用？有什么用？

* 一般我们说离线应用，就是说在设备上不能上网的情况下仍然可以运行的应用，常见于app

> 我们这里强调Web应用

* 至于离线应用有什么用？当然显而易见，就是可以实现单机操作，没网络后还能有一定的功能给用户操作，这个关于用户体验，很重要，避免用户处于断网或网络差的时候出现一堆NB的问题

#### 开发离线web 应用的几个步骤

1. 首先是确保应用知道设备是否能上网

2. 然后应用还必须能访问一定的资源

3. 最后必须有一块本地的储存空间用于保存数据

## 重点知识

#### 离线检测 navigator.onLine

	HTML5 定义了一个navigator.onLine属性。这个属性值为true表示设备可以上网，值为false表示设备离线

``` js
if(navigator.onLine) {
	// 正常工作
} else {
	// 执行离线状态时的任务
}
```

* HTML5还定义了两个事件：online和offline。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。

``` js
EventUtil.addHandler(window,"online",function(){
	alert("Online");
});
EventUtil.addHandler(window,"offline",function(){
	alert("Offline");
})
```

> 这样可以实现完美切换，避免出现用户体验极差的情况出现，尽量覆盖各种问题

#### 应用缓存

	HTML5的应用缓存，或者简称为appCache，是专门为开发离线Web应用而设计的。
	是从浏览器的缓存中分出来的一块缓存区（大小根据具体浏览器而定，一般是5M）

###### 应用缓存流程

* 要想在这个缓存中保存数据，可以使用一个描述文件(manifest file)，列出要下载和缓存的资源

``` js
CACHE MANIFEST
#Comment
 
file.js
file.css
```

* 在`<html>`中的`manifest属性`中指定这个文件的路径，将描述的文件与页面关联起来

``` html
<html manifest="/offline.manifest">
```

* 这个API的核心是applicationCache对象

	有一个status属性，作为一个常量存在，用于判断应用状态

		0：没有与页面相关的应用缓存（未缓存）
		1：应用缓存未得到更新（空闲）
		2：正在下载描述文件并检查更新（检查中）
		3：应用缓存正在下载描述文件中指定的资源（下载中）
		4：应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了（更新就绪）
		5：应用缓存的描述文件不存在了，页面无法再访问应用缓存（已过期）

> 当然，应用缓存还有很多相关的事件可以表示其状态的改变

* checking

	在浏览器为应用缓存查找更新时触发
	并且每次载入一个设置了manifest属性的HTML文件，首先会触发checking事件

* error

	在检查更新或下载资源期间发生错误时触发
	如果处于离线，无法检测清单状态，则触发error事件，如果引用一个不存在的清单文件，也会触发error事件

* noupdate

	在检查描述文件发现文件无变化时触发
	如果应用程序已经缓存，并且清单文件没有改动，则浏览器触发noupdate事件

* downloading

	在开始下载应用缓存资源时触发

* progress

	在文件下载应用缓存的 过程中持续不断地触发

* updateready

	在页面新的应用缓存 下载完毕且可以通过swapCache()使用时触发
	如果应用程序已经缓存，并且清单文件发生改动，则浏览器触发downloading事件，下载完毕后触发updateready事件

* cached

	在应用缓存完整可用时触发
	如果应用程序未缓存，则downloading事件和progress事件都会触发，但是下载完成后触发cached事件而不是updateready事件

* obsolete

	如果处于在线，应用也缓存了，但是清单文件不存在，则会触发obsolete事件，并将应用程序从缓存中清除。

> 其中，还有个常用的update()方法

	update()一经调用，应用缓存就会去检查描述文件是否更新。
	然后就像页面刚刚加载一样，继续执行后续操作。如果触发了cached事件，就说明应用缓存已经准备就绪，不会再发生其他操作。
	如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时要调用swapCache()来启用新应用缓存。

``` js
applicationCache.update();	// 检查应用缓存更新
```

``` js
EventUtil.addHandler(applicationCache, "updateready", function(){
	applicationCache.swapCache();	// 启用新应用缓存
})
```

> 注：浏览器检查清单文件，以及更新缓存的操作是异步的，可能是在载入旧缓存之后进行，也可能需要载入两次才能显示最新的内容，因此需要提示用户

``` js
window.applicationCache.onupdateready = function(){
        var con = confirm('有新内容可用，是否重新加载？');
        if(con){
            location.reload();
        }
    }
```

**页面加载触发顺序**

1. 每次载入一个设置了manifest属性的HTML文件，首先会触发checking事件

2. 如果应用程序已经缓存，并且清单文件没有改动，则浏览器触发noupdate事件

3. 如果应用程序已经缓存，并且清单文件发生改动，则浏览器触发downloading事件，下载完毕后触发updateready事件

4. 如果应用程序未缓存，则downloading事件和progress事件都会触发，但是下载完成后触发cached事件而不是updateready事件

5. 如果处于离线，无法检测清单状态，则触发error事件，如果引用一个不存在的清单文件，也会触发error事件

6. 如果处于在线，应用也缓存了，但是清单文件不存在，则会触发obsolete事件，并将应用程序从缓存中清除。


###### 应用缓存的作用

* 离线浏览

	让用户在离线后可以实现一定程度的单机操作

* 加载速度更快
	
	已缓存资源加载更快

* 减少负载

	浏览器只从服务器下载更新过的文件

> 一个web应用首次下载并缓存之后，任何加载请求都优先来自于缓存，因此可以实现离线缓存。如果不需要使用离线缓存了，就需要在服务器端删除描述文件，或者删除HTML页面中的manifest属性

###### 更新应用缓存的方法

* 用户清空应用缓存

* manifest文件被修改

* 使用update()方法更新缓存

> 如果服务器上的文件有所修改的话，那么修改描述文件中注释行的日期或者版本号是一个不错的使浏览器重新缓存文件的办法；当然常见于使用HTML5的API操作实现更新

###### 应用缓存和网页缓存的区别

* 应用缓存为整个web应用程序服务，网页缓存服务于单个网页

* 应用缓存只缓存指定页面需要的指定资源（可人为控制），任何网页都具有网页缓存（浏览器默认行为）

* 应用缓存不会随着清除浏览器缓存而消失

* 应用缓存不会像网页缓存那样，老数据会被最新一次的新数据替代

* 应用缓存可以离线访问，网页缓存必须在线访问

* 应用缓存可靠，可控，网页缓存不可控

#### 数据存储

	Cookie、IE用户数据、Web存储机制、IndexedDB

* 通过这些存储方式让我们在应用离线之后有很大的操作空间，尤其IndexedDB存储机制，可以实现比较大而复杂结构化数据存储，让很多离线单机操作成为可能，直接读取本地缓存数据

> [本地存储](知识笔记/大前端/其他/存储方式/本地存储.md)


> 参考：[离线应用与客户端存储学习笔记](https://blog.csdn.net/weixin_42659625/article/details/82826443) | [HTML5--离线缓存应用](https://www.jianshu.com/p/98cd7a6985ac)
