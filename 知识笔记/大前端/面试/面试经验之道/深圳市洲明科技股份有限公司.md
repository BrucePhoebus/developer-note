<!--
 * @Date: 2021-04-30 15:38:26
 * @LastEditors: 郑烨锟
 * @LastEditTime: 2021-05-05 19:35:31
 * @tags: 	
 *  - 面试
 *  - 经验
-->
# 深圳市洲明科技股份有限公司

### vue1到vue3的变化

###### 从Vue1.0到Vue2.0

1. 根元素是否包含。Vue2.0开始必须有根元素包含

2. 组件定义方式。Vue2.0增加了更便利的组件定义方式

3. 生命周期变化。Vue2.0什么周期有较大的变化：创建前创建后、挂载前挂载后、更新前更新后、销毁前销毁后

4. for循环优化。Vue2.0的循环$index和$key在循环的过程中定义，而之前存在不能重复添加重复的数据

5. 元素附唯一值。2.0之后变为使用key作为元素唯一值

6. 自定义指令。2.0自定义指令简化了

7. 过滤器。2.0移除了自带过滤器功能(参考angular)，可自行定义且使用方式有语法差别

8. 全局配置。移除一些全局配置属性

9. 其他。事件、插槽、keep-alive变为包裹组件、一些围绕DOM的实例方法被移除、一些底层示例方法($eval等)被移除、移除一些全局全局API属性、Props 的参数取消`coerce`定义

> 参考：[vue 1.0和vue 2.0的变化和区别](https://www.imooc.com/article/34607)

###### 从Vue2.0到Vue3.0

1. 结构部分。main.js初始化Vue示例语法变了，3.0暴露createApp方法

2. 组件语法部分。3.0主要针对api的优化并兼容2.0写法，2.0是选项式api，而3.0是组合式的API。

  - 数据响应式

  - watch使用

  - computed使用

3. 组件间的通信

  - setup

  - 渲染函数 h

> 具体？

1. 2.0使用`Object.defineProperty`方法实现响应式数据，3.0使用`proxy`实现响应式数据

  - `Object.defineProperty`的缺点

    - 无法检测到对象属性的动态添加和删除

    - 无法检测到数组的下标和length属性的变更
  
  - 解决方案

    - 2.0提供了`$set`动态给对象添加属性

    - `$delete`动态删除对象属性

    - 重写数组方法，检测数组变更

  - `proxy`的优点：在对象外层加了一层，所有进出都被拦截

    - 可以检测到代理对象属性的动态新增和删除

    - 可以监测到数组的下标和length属性的变化

  - `proxy`的缺点

    - es6的proxy不支持低版本浏览器（IE11）

    - 会针对IE11出一个特殊版本进行支持

> Vue3.0的新特性

①：数据响应重新实现（ES6的proxy代替ES5的Object.defineProperty）

②：源码使用ts重写，更好的类型推导

③：虚拟DOM新算法（更快、更小）

④：提供了composition api，为更好的逻辑复用与代码组织

⑤：自定义渲染器（app、小程序、游戏开发）

⑥：Fragment，模板可以有多个根元素

### Vue虚拟DOM的作用

  将多次需要对DOM操作的行为合并一次提交给浏览器，这些diff内容保存到JS对象，最后一次性attach到DOM树上，而这个JS对象就是虚拟DOM树

- 这个过程主要是避免了大量的更新计算，通过更快计算能力的JS引擎操作更多的计算，而将最终效果映射到真实DOM，也减少了渲染次数

- 这个对虚拟DOM对象的操作过程就是`DIFF`算法，模拟真实DOM节点

### Vue的优点和问题

- Vue是响应式的，一切基于数据，一切操作数据，快速响应，通过对数据的监听实现响应式更新，然后通过虚拟DOM的优化，最后让浏览器渲染，但也导致存在缺陷

- 2.0因为使用了`Object.definedProperty`响应式处理，导致无法监听对象变更或数组内部变更，但是也是通过`$set`、`$delete`做了优化解决方案，这个问题3.0已经解决

- 因为是单页面应用，所以存在SEO问题，服务端渲染可解决

- 首次加载需要加载更多资源，当然可以很多方式优化解决，例如打包优化、CDN、gzip压缩、动态路由按需加载，后续使用浏览器缓存就会很快

### Vue与React的选择差异

- 思想。all in js还是all in data，思想差别很大，也就导致React对初学者更不友好；模板 vs JSX。Vue的成本更低，React的要求更高

- 社区。实际上React社区更丰富，全球范围，而Vue实际上中国使用比较多而已，React的解决方案比较多

- 性能优化。React很多性能优化都是要手动处理，而Vue的自动处理，那么对于初学者Vue肯定很友好，但是当我们到大项目或特殊场景，Vue的自动优化将成为阻碍，其中响应式机制就是这样，过多的state需要监听响应，会影响性能，而React是可控的，一切如搭积木，Vue实际上是像个平台，如果特殊场景需要动平台的修改，成本就比较高，解决方案也不好说。当然，常规应用实际上需要根据复杂度选择

- 类还是声明式。Vue2.0是声明式的实现，Vue提供各自API、指令、语法糖使用，而React是类式实现，尤其是高阶组件，React实现比较好，Vue需要比较多的辅助，当然3.0就不一样了

- 数据可变与不可变。react为不必要的渲染和重绘影响性能，使用单向数据流，需要setState触发更新，相对Vue就比较繁琐，但是Vue因为响应性需要使用虚拟DOM解决性能问题，而DIFF算法的性能就比较大关乎响应式的性能处理

> 虽然都是组件化，实际上React的组件是就是在写函数，all in js，all in 函数，但是Vue的组件就是一个组件，一个块，一个单文件组件

- 为啥说React会了Vue就很容易上手

> 因为都是组件思想，React有种Vue更原生态的表现，当会了React，对比较偏向应用的Vue实际上很容易理解，也就更容易上手，就像Linux用多的来用Windows

### 实时大屏数据问题

- 可以使用`socket.io`兼容解决长连接实现数据实时更新问题

> 当然，大屏还有其余硬件传输方案，但是前端不知道，只是听过

### 前端内存泄露

###### 方式

1. 循环引用

  - COM组件产生的对象实例和js对象互相引用。需要想办法断开两者之间的引用

2. 内部函数引用(Closures)。递归死循环，闭包

3. 页面交叉泄漏(Cross-Page Leaks)。DOM插入顺序问题

> 大部分内存泄露在开发的过程中就很容易被发现，但是存在一些是坏习惯导致不用的东西却一直占用着内存，无法被及时垃圾回收，闭包也是一种方式，需要在不使用的时候手动回收，凡是需要手动回收的都手动处理了

###### 具体

1. 定时器未清理

2. DOM对象与JS对象相互引用无法回收

3. 大量变量导致内存过量暂用(垃圾程序)

### 浏览器内核

- 这些主流浏览器主流引擎应该算是谷歌/Safari用的`Webkit内核`，而360等多个国内的浏览器实际上很多都是用来精简版的`Webkit内核`

- 而著名的还是有IE的`Trident内核`和火狐的`fireFox内核`

- 而所谓的兼容模式，就是加上了`Trident内核`，也可以叫`IE内核`，例如360

- 而现在的谷歌内核一般用于渲染引擎，而JS会有单独的JS引擎处理

- 现在移动端也基本上都是用`webKit内核`

### promise

###### 异步的发展和问题

1. 回调函数(callback)。会出现回调地狱，嵌套耦合，不合理， 并且因为不能用try catch捕获错误，也不能return，当然它解决了同步问题，解决同步阻塞问题

2. Promise。这是ajax时代，解决了回调地狱问题，存在的问题是无法取消，只能在回调结束处理，异常也是在异常捕获处理，当然axios做了一层优化，通过`cancelToken机制`实现了取消

3. Generator。这个阶段可以控制异步函数执行

4. Async/await。异步终极解决方案，在Promise的基础上进一步实现了优化，代码清晰，以同步的代码形式书写异步代码，相当于generator`加上`Promise`的语法糖

###### 实现一个promise

```js
// Promise的三个状态，定义成常量
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class myPromise {
	constructor(callback) {
		this.success = null;
		this.fail = null;
		this.msg = "";
		this.queue = [];

		callback(
			success => {
				this.msg = "SUCCESS";
				this.success = success;
				this.queue.forEach(item => {
					item.resolve(success)
				})
			},
			fail => {
				this.msg = "FAIL";
				this.fail = false;
				this.queue.forEach(item => {
					item.reject(success)
				})
			}
		);
	}
	then (success, fail) {
		return new Promise((resolve, reject) => {
			if (this.msg === "SUCCESS") {
				success(this.success)
			} else if (this.msg === "FAIL") {
				fail(this.fail)
			} else {
				//如果是异步就先站队
				this.queue.push({
					resolve: success,
					reject: fail
				})
			}
			function handle(value) {
				// value为resolve的值（需要传给第一个then的值并传递过去）
				let resValue = (success instanceof Function && success(value)) || value
				// 如果返回值的是一个promise对象
				if (resValue && resValue.then instanceof Function) {
				resValue.then(
					success => {
						resolve(res) //把值存到新的this.success中，等下一次then调用
					},
					fail => {
						reject(fail) //把错误存到新的this.fail中(只要上次不是promise对象就不能then了)
					}
				)
				} else {
					//其他的值就直接存进下一次then方法成功回调函数的参数中
					resolve(resValue)
				}
			}
		})
	}
}

new myPromise((resolve, reject) => {
	function fn() {
		resolve("成功");
	}
	setTimeout(fn, 1000);
}).then(data => {
	console.log(data);
}).then(data => {
	console.log(data); // '成功'
})
```

> 参考：[实现一个Promise](https://zhuanlan.zhihu.com/p/62488780)

### 宏任务和微任务，事件循环机制

- 这个事件循环机制也就是js引擎的执行工作机制，通过消息队列来实现协调，而这个消息队列就包含了 宏任务和微任务

- 这个消息队列代表一堆带执行的有序任务，其中每个任务都有一个源，这些相同源的任务被放在同一个任务列表，不同源则不同任务列表

- 每一次循环都是检查这些任务队列，如果存在任务(先进先出执行)，则执行，执行结束宏任务队列中的此次序列任务后，会检查是否有微任务，有则执行完进入下次宏任务

- 那么异步程序怎么执行，异步程序(属于程序块)会被放在宏任务列表，等待循环执行，也就是排队

- 上面就是宏任务和微任务的执行顺序，但是事件循环机制还有更新渲染部分逻辑

- 首先进入循环依旧是检查队列先进先出执行宏任务，过程有异步任务则放入宏任务列表等待循环执行，执行完宏任务就进入微任务检查执行，执行完，则render更新，然后主线程继续循环 - 事件循环机制

> 注，这个过程异步任务虽然也是宏任务，但是都是排在同步任务执行完之后进行执行

- 每一次宏任务列执行完 + 微任务执行完后，会进行浏览器渲染，在下次循环来临之前

###### 宏任务与微任务区别

- 宏任务可以理解为一个程序库，可执行程序命令代码，例如script，当然也包括setTimeout和setInterval这些，主要是宏大任务

- 微任务一般是js引擎执行的封装的js支持的功能程序，例如`Promise.then`、`Object.observe`等内置功能

> 除了这些记住特殊的就好

- 宏任务：

	- script(整体代码)
	
	- setTimeout
	
	- setInterval
	
	- I/O
	
	- UI交互事件
	
	- postMessage
	
	- MessageChannel
		
	- setImmediate(Node.js 环境)

- 微任务

	- Promise.then

	- Object.observe

	- MutaionObserver

	- process.nextTick(Node.js 环境)

> 记住`script程序库`和`setTimeout`、`setInterval`是宏任务，`Promise`和`Object`的是微任务

### watch 和 computed的区别？

- computed具有缓存机制，节省性能开销，可以依赖其他computed，当然不能与data变量重名，问题可能是缓存会占用内存，所以如果需要显示一个计算属性的时候用这个就方便。；并且这里面做了很多灵活优化处理，例如当没在模板中使用时是不会触发更新的；当然如果对象中不确定值的变化可能就不方便处理，它一般处理确定属性的计算

- watch。监听对象或属性，监听属性的时候可以和computed实现一样的作用，尤其是监听可以触发一些回调，做很多很自由的处理，所以非常常用，而computed像是指定功能的watch；通过配置immediate属性判断是否初始化就触发，通过deep确定是否深入对象监听，两者都是不错的功能，但是很明显deep深入对象监听是需要消耗性能的，尤其是复杂处理要慎行之，出现过监听回调渲染刷新不及时的问题，后部分异步处理解决；当然也出现过死循环问题，相比computed风险更大。

### 你知道Vue中key的作用和工作原理吗？说说你对它的理解。

- 更加高效，减少DOM操作，提高性能。首先重点是元素唯一标识，避免出现循环多个元素重名，实现虚拟DOM高效更新，这个过程就是通过key判断两个节点是否同一个节点的作用，避免频繁更新相同的元素

- 原来处理列表更新删除等这些存在渲染隐藏bug，而通过key可以比较好解决

- vue在相同标签过渡切换的时候也会使用到key，方便Vue识别而触发过渡效果
