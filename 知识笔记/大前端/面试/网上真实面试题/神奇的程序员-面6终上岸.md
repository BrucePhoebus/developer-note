# 神奇的程序员-面6终上岸

### 首先给个个人评价

- 首先遇到这种环境肯定是很伤感的，一大堆麻烦事，但是他能意识到环境的变化，并作出改变，实际上已经跑赢你一部分人了，给自己带来更多机会

- 当然，很遗憾的是他曾经不努力只有大专学历，让我想到自己曾经的不够努力，实在是让人很伤感，在这个这么内卷的时代，不够努力的人，这苦果够吃一辈子

- 当然，他很幸运，因为他懂得努力，技术上的努力虽然让他够不着大厂，但是还是有很多小厂的机会，这个时代还是有很多机会的，就是越小的公司坑越多，到了这个年龄，我们越来越追求良好的环境，他也找到了一个合适的，这是他努力的成功，祝福他

> 不过最后想说，我们很多人处于一个不是很良好的环境，我们经常不懂得培养良好的习惯，良好的技术习惯，良好的思维习惯，良好的能力系统，这是或许我们和那些人最大的差距吧，可惜这种差距是最难解决的，只是，如果没有这种意识，那永远也没有解决的可能，希望我们每个人都能懂得，都能寻找到一些

### 面试题学习

###### vue源码

- 简单看过一些源码，也看过一些相关的教学视频，对Vue的初始化到构建挂载等一些回调逻辑，但是并没有深入细节

- 也就是没有专门研究

###### vue的组件化，用到哪些技术点，平时是怎么组件化开发的

- 关于组件化的思考，我一般对通用模块都会考虑抽离出一些组件

- 平时主要分为业务组件和功能组件，比例都差不多吧

- 例如功能组件，会抽离全局的分页组件、table组件，这些都是业务上常用的一些组件，这些功能组件抽离主要是规范项目一致性，也方便维护。功能组件一般考虑多个功能模块使用时抽离的通用组件，例如表单这类，例如列表这类，例如一些echart图，例如一些选择树组件，多数都有实现过

- 业务组件一本是抽离复杂页面的一个块，蕴含独立的业务逻辑，他们也是单文件组件，也可以独立存在，或者依赖输入参数，当然，作为子组件，一般都是有props进行参数传递的

- 至于组件抽离的实际，一般要根据业务场景，过于小的项目，例如echart图，可能就用到一两个地方，无所谓抽离，例如表单列表分页这类常用则一般都会抽离，当然，很多时候是直接拿以前的进行细微改造

- 关于组件化的技术，浅层组件交互常用`props`和`$emit`，然后之前还有用过`eventBus`、`$emit/$on`中间车间多兄弟组件通讯 ，至于组件库式的传递听说`provide/inject`进行隔代深层次的组件传递，简单用过，但是并没有深度实践

- 平时基本上就是简单是父组件参数传递和接受子组件的通知回调

- 至于`parent/children`等其余通信方法比较少用

> 还有那些呢？

1. 插槽

	- 预留位置

	- 使用插槽可以减少组件依赖，例如不用状态控制，进一步解耦的组件化方式

	- 例如使用作用域插槽可以轻易取得子组件数据使用

###### Vue3.0和Vue2.0的区别

- 语法的改变，使用了类式语法，使用了typescript，暴露createApp方法进行Vue实例化

- 改为使用`proxy`进行响应式处理，解决了`Object.definedProperty`带来的对象数组等无法良好监听响应的问题

- 主要是这两方面，当然，还有使用setup等这些东西，以及虚拟DOM算法优化，自定义渲染器等等，这些就不熟了

- 这里细点：[深圳市洲明科技股份有限公司](知识笔记/大前端/面试/面试经验之道/深圳市洲明科技股份有限公司.md)

###### 为什么Vue3.0使用proxy性能更好呢？

- proxy是es6的语法，具有更强大的功能，是直接拦截对象，而不是拦截属性，并且提供很多拦截方法，直接解决了2.0存在的对象处理问题，提高了性能

- 当然也是有负面作用的，兼容性相比es5的`Object.definedProperty`差，但是这个技术将持续被厂家兼容，不断的进行性能优化

###### proxy的缺点是什么？为什么比`Object.definedProperty`快

- 缺点主要是兼容性的问题，使用es6的语法，对一些环境的兼容性可能存在问题，也就是对兼容性比较强的需求的项目可能不太方便使用这个技术，或需要特殊转码解决，对很多企业并不是多么好的选择，暂时

- 快的原因是，解决了原本`Object.definedProperty`的问题，原本`Object.definedProperty`监听属性而无法直接监听对象内部变化，需要对对象内部进行复杂监听处理，例如数组需要重新创建来触发监听，虽然提供了`$set/$delete`语法处理，但是实际上也是消耗性能的，而proxy则是原生支持直接监听对象的变更

###### `Object.definedProperty`是什么样的机制

- 首先`Object.definedProperty`可以直接在一个对象上操作这个存在亦有的对象或熟悉，增删查改，或设置对象/属性的属性，例如设置内部属性不可改(默认就是不可改的)，可以通过`get()/set()`方法操作


- 那么Vue就是通过这个方式实现对数据的监听回调，也就是双向绑定

- 当然，这里面操作的是一个个属性，也就是箭头的是一个个属性，如果想要监听一个对象，这个就做不到了，所以对这种情况Vue就需要另作处理了，例如递归出来，通过hasOwnProperty识别所有对象，然后对所有对象都判断处理一遍

- 那么很明显这就比较消耗性能了

###### Object.definedProperty与proxy有那些区别

- 前者是监听一个个属性，而后者直接拦截对象，区别很大

###### vue3打包按需引入如何做到，为什么vue2没有做到

Tree-Shaking实现内部组件ES导出，这样内置组件实现按需引入

> [快速了解vue3.0新特性](https://www.bilibili.com/read/cv6429077)

###### 你在vue项目做了哪些性能优化

1. 打包优化。拆分文件、代码压缩、gzip压缩、抽离公共插件

2. CDN加速。将部分静态资源使用CDN引入

3. 路由按需加载

4. 页面资源按需加载现实，图片懒加载

5. 浏览器缓存

6. 大数据量的分页和查询

7. v-if和v-show的使用

> [手把手教你深入Vue3.0(Vue-cli4)项目打包性能优化实践](https://blog.csdn.net/qq_36824777/article/details/106407846)

> [Vue 项目性能优化 — 实践指南（网上最全 / 详细）](https://zhuanlan.zhihu.com/p/78467131)

###### 有没有了解http缓存

- 知道可以进行资源是否缓存设置，`cache-control`，可以设置不缓存、缓存、缓存时间等

- 尤其是项目token设置的时候，可能需要设置缓存时间`Expires`

- 也有你协商缓存和硬性缓存这两个概念

- 时常在Vue项目中，会根据需要缓存的路由页面设置缓存，`keep-active`

- 这方面有了解，但是业务应用得少，就没有深入了，实际上是忘了

###### 硬性缓存对应的是那个header值

	只要缓存有效，就直接读取缓存数据

1. expires

2. cache-control

###### 说下协商缓存，协商缓存会在什么时候取得

- 协商缓存是由服务器确认资源是否可用，也就是浏览器会拿资源的请求头去找服务器验证有效性，无效则重新获取

- 这里面主要是判断`Last-Modified`或者`Etag`，如果服务器返回304则浏览器会直接读取缓存

> `Etag`是`HTTP1.1`为解决前者出现的一些问题来更精准的控制缓存

###### 有哪些资源的缓存策略，html、css、js是怎么设置缓存

- 对不常变的资源可以手动修改版本/后缀实现资源更新

- 而对其余的资源也是后缀变更实现，不过一般工程化项目会直接使用hash作为后缀，实现项目更新，如果某种资源固定没有变化，hash值也就不会变化，这个可以通过配置webpack插件打包处理

- 当然也可以使用http缓存实现，也就是对某些资源使用强缓存，需要变更的时候手动修改路径或后缀版本参数

- 而协商缓存是常见设置，或直接设置不缓存也是可以的

###### Vue的插槽机制是怎么样的？如何使用？

- 相当于留一个位置，直接将Vue模板传进去，比起传参可以实现更加灵活的操作，也是一种灵活的组件思想，并且可以实现默认值替换功能

- 并且相当于一小块组件，由于是在父组件中使用，可以自由变量控制而不需要复杂的传参，也就是这个子组件将变数大的组件块用插槽填充，这样就不需要限定各自格式和传参接口，非常灵活

- 例如一个布局灵活多样的列表组件，将允许自定义的行使用插槽暴露，并且使用默认值，这样就允许默认使用标准化的列表，也可以让用户自定义使用，通过插槽语法，使用时替换默认插槽模板代码，就这么简单

###### 插槽有哪些API？插槽的作用域

- 最简单是插槽直接使用slot标签实现，这是默认插槽

- 具名插槽是在一个组件有多个插槽的时候通过添加attribute属性name作为区分

- 作用域插槽。因为插槽实际上是将模板传到到子组件一起渲染，那么这个时候需要使用到父组件的变量的话就需要通过v-bind将参数注入进入，也就是相当于插槽的prop绑定上去，默认命名是`slotProps`。

> 作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数(slotProps)的函数里

###### 具名插槽如何使用？

- 子组件通过在元素上添加slot属性标明这是具名插槽，不加的则是默认插槽，然后父组件通过在slot插槽标签中name区分，对应不同名字的插槽

###### 自定义组件的双向绑定怎么写？

- 如input组件的双向绑定是对父组件emit进行通知，也就是通过prop和$emit这种通信回调可以实现双向绑定。如input change回调修改$emit通知父组件，然后触发父组件修改

###### 父子组件如何通信，除了emit和evenBus外还有哪些？

- 主要用的就是emit和evenBus进行简单通信，听说常用于组件库开发无限传递通信的provide/inject，当然还有children和parent父子通信以及attrs/listeners隔代通信等

- 全局通信实际上还有用过Vuex，加个监听

###### Vue双向绑定的sync有了解过？

- 这是一个vue v-bind的修饰符，也就是一种语法糖，是实现组件和外部数据的直接双向绑定

- 以前我们是使用emit实现通知父组件更新的，例如emit/on，也可以使用update这个修饰符，而现在直接可以使用sync这个修饰符达到同样的效果，而不需要emit，相当于update的语法糖，又方便了，直接实现父子组件双向绑定

###### Vue响应式对数组做了什么额外处理？

- 如果直接通过下标修改数组，Vue是无法监听到的，而通过数组原生函数修改是可以监听到的，Vue重写了数组原生函数，加了notify分发通知，实现变更监听，如果splice这个函数就做了触发分发的操作

- 还有提供了$set语法支持对数组的操作，这个$set也支持对对象的修改，实际上是一个逻辑

###### 知道数组哪些API会改变原函数？

1. pop：弹出一个元素，也就删掉一节，直接修改原数组长度

2. push：添加一个元素，也就加上了一节，直接修改原数组长度

3. splice：添加或删除数组部分，返回被删除的部分，直接操作数组长度

4. shift：删除头部元素并返回，直接修改原数组长度

5. unshift：插入元素到头部。返回新数组长度，直接修改原数组长度

6. sort：排序，会改变原数组内容

7. reverse：翻转，直接修改原数组内容

8. fill：填充数组，批量覆盖或初始化数组，直接改变原数组内容

9. copyWithin：ES6新增的数组函数，直接指定位置插入一段数组，可覆盖原来数组部分，即改变长度，也改变内容

###### 说说对解构的理解

- 首先常用的是接受对象数据的时候我们可以通过结构函数，将一个对象展开，甚至深层次展开，并明确声明赋值部分对象内部变量，包括import在引入一些文件的多个函数对象的时候也一般会用

- 同时这个结合三点展开一个对象，将一个对象浅拷贝到另一个对象，这里的对象包括大括号的对象，也还有数组，字符串实际上也被支持

- 解构，如同字面上就是解析，就是拆解，将一个对象拆解成多个属性，这个同时也可以自动转为符合的类型，例如对象转为数组，自动将内容push到数组中，这就是语法糖了，其次一一对应，这种支持让声明赋值更加精准明确，也要求传入的参数应该有这个字段，有一定的明确声明意义，当然用起来最重要是方便

###### 说一说剩余参数，它是如何使用的

- 剩余参数允许我们接受不定数量参数，并且表示为一个数组，以`...`语法标识该参数是剩余参数，接收之后的所有变量存储于当前变量

- 接收之后就是一个数组了，当作一个数组使用即可，也可以直接使用解构语法，当然这个跟脱了裤子放屁一样，剩余参数的目的本身就是接收不确定参数

- 其本质实现是用arguments接收参数然后转为数组存在

###### 解构时，如何给一个变量赋默认值？

- 额，这个解构场景是什么？是接收参数的时候？那直接在解构参数等于一个默认值即可，如果是一个新的变量，那就直接对原有变量冒号一个新的变量等于一个默认值

```js
const info = {
	name: 'zyk',
	age: undefined
}
let { name: nickName = '新变量默认值', age: '默认值' } = info
```

###### 你是怎么使用Promise的？

- 必较常见的使用是在需要异步等待的代码中new一个Promise实例，然后then then回调处理，当然有些时候使用`async/await`更优雅，同时并发的时候也会用到

###### 如何把一个请求封装成Promise方式？

- 很简单，例如ajax，把ajax请求封装在Promise实例中，返回这个promise对象，如果ajax成功就resolve，如果失败就reject

###### then可以接收什么回调，它可以接受失败回调？

- promise的then接受resolve完结的回调，如果这次异步完成，无论执行是何结果都可以then，只是对应resolve状态，失败回调也可以放到then另作处理，而常常promise的catch我们常常用reject状态完结，具体失败回调是放catch统一处理还是resolve进入then表示完结另作处理看具体业务

###### 在线聊天系统 - chat-system

> 参考学习：[在线聊天系统](https://gitee.com/gezi18/chat-system)

###### TypeScript泛型，使用方式和场景

- 泛型在不同类上可以实现不同参数类型的实例，对应组件就是不同类型的组件，也就是实现组件重用

- 跟Java用的好像差不多，也就是标签符T，在创建实例的时候使用不同类型创建，那么整体实例类型就不一样，同样使用在函数

- 例如我们创建集合存储处理数据，那么我们就可以通过泛型实现程序复用，一套程序实现可以创建多种类型集合

###### 如果接口返回promise类型的数据，你如何个用TypeScript声明它？

- 在声明文件定义期许返回类型的数据类型，然后再返回promise类型的函数中冒号声明Promise类型参数为这个期许类型(把这个对象放进去)

```js
declare namespace Service {　　
	interface login {
		id: string
		name: string
		date: Date
　}
}
export default function login(): Promise<Service.login> {
	return new Promise(resolve => {
		axios.get('url', param).then(res => {
			resolve(res);
		});
	});
}
```

###### 举一个你在项目中使用typescript泛型的例子

	没有用过

- 可以在模拟组件中使用

```ts
abstract class Component<T1, T2> {
    props: T1;
    state: T2;
    constructor(props: T1) {
        this.props = props;
    }
    abstract render(): string;
}

interface IMyComponentProps {
    val: number;
}

interface IMyComponentState {
    x: number;
}

class MyComponent extends Component<IMyComponentProps, IMyComponentState> {
    constructor(props: IMyComponentProps) {
        super(props);
        this.state = {
            x: 1
        }
    }
    render() {
        this.props.val;
        this.state.x;
        return '<myComponent />';
    }
}
let myComponent = new MyComponent({ val: 1 });
```

###### 如何使用typescript的联合类型?

- 在声明返回值类型的时候或传入值类型的时候或上其他类型，标明可以不止一个类型

- 例如在字符串和数值类型一同处理的时候，可以允许这两种类型传入，当然一般返回类型应该是固定的，不一般的是异常处理结果需要返回非正常类型

###### 说一下typescript中的内置类型

- `Partial`。标记可选，这个常用，将类型 T 的所有属性标记为可选属性

- `Required`。标记必选，这个常用，将类型 T 的所有属性标记为必选属性

- `Readonly`。标记只读，这个常用，标记属性不能修改

- `Pick`。过滤属性，从某个类型中过滤出某个或某些属性

- `Record`。标记类型，标记对象属性或属性值的类型

- `Exclude`。移除属性，移除特定类型中的某些属性

- `Extract<T, U>`。交集属性，Exclude的反向操作，去两者的交集属性

- `NonNullable`。排除null属性，排除类型为null或undefined的属性

- `ReturnType`。返回类型，这个常用，获取函数的返回类型

> 参考：[TypeScript 中的内置类型](https://blog.csdn.net/u014627807/article/details/108002767)

###### 说一下 typescript中的pick类型?

- 过滤属性，从某个类型中过滤出某个或某些属性

```ts
// 通过pick语法获取对象的指定类型的属性内容
type person5 = Pick<Person, "name">;
// person5 === { name: string }
```

###### 如何使用typescript定一个一个对象类型?

```ts
private data: { [name: string]: DataModel };
this.data = {};
```

###### 说一下typescript中的type与interface的区别

- 都可以描述一个对象或函数，基本只是语法不同，也支持拓展

- 但是type可以声明基本类型别名、联合类型、元组等类型，可操作性还是比较大

- 而interface可以声明合并，算是一个小差异吧，而OOP我们主要用interface，也一般用这个

- 普通项目尽量使用interface，对于OOP项目在明确的时候是使用interface，其余场景可以考虑用type，例如定义function

###### 说一下typescript中的交叉类型

- 交叉类型取的是并集，也就是拥有两个类型成员的所有属性

###### 聊一下css，你用的什么布局多一点

- 我应该使用浮动自适应布局比较多，当然偶尔组件开发也会用到flex的布局方式，包括实际上经常用到的element的布局就是flex布局，当然只是用

> 很遗憾，我只选了一个最简单的解决方案，并且对其余方案没有都会

###### 说一下flex中，你常用的的属性?

1. 元素属性

- `order`。排序

- `flex-grow`。元素放大比例

- `flex-shrink`。元素缩小比例

- `flex`。flex-grow，flex-shrink和flex-basis的简写

2. 容器属性

- `justify-content`。定义元素在主轴上的水平对齐方式，也就是水平属性，center居中对齐，flex-start左对齐，flex-end右对齐，space-between中间均分两边无间隙对齐，space-around中间均分两边有间隙对齐

- `align-items`。定义元素在主轴上的垂直对齐方式，也就是垂直属性，center上下居中对齐，flex-start上对齐，flex-end下对齐，stretch未设置高拉满高填充，baseline多元素以第一行文字为基准对齐

- `flex-wrap`。换行方式，normal不换行，wrap第一行在上方，wrap-reverse第一行在下方

- `flex-direction`。主轴方向，row从左到右水平方向，row-reverse从右到左水平方向，column从上到下垂直方向，column-reverse从下到上水平方向

- `flex-flow`。flex-direction属性和flex-wrap属性的简写形式

- `align-content`。多线轴对齐

> [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

###### flex溢出换行用的哪个属性?

- flex-wrap

###### 主轴与交叉轴的方向用哪个属性定义?如何颠倒这些属性?

- flex-wrap: wrap-reverse; 不需要知道方向，属于针对容器的颠倒

###### 说一下flex-grow怎么使用?

- 按比例占据剩余空间，将空间填充

- 设定父元素display为flex布局，在子元素设定flex-grow大小占据比例值

###### 说一下css的选择器都有哪些以及优先级?

1. id选择器

2. class选择器

3. 元素选择器

4. 属性选择器

5. 通配符

6. 伪类选择器

7. 组合选择器

	- 后代选择器

	- 子选择器

	- 直接兄弟选择器

	- 兄弟选择器

> 优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器

###### css实现10列布局如何做?

- 可以用CSS3的columns属性多列布局

- 可以用flex布局的`flex-wrap`不换行10列一排

> 让文本像报纸一样自动多列显示，可以轻松实现瀑布流布局

###### 如何实现通过不同的类名，来控制它的均分?比如我传col2，那么这- - -列就占20%，col3 就占30%

- flex布局，按比例设置col2的flex-grow

- 直接设置col2的比例就是20%，然后内部100%填充

###### 让元素横着排列，除了flex还可以怎么做?

- 如果允许滚动条，那就是父元素设置white-space为normal

- 如果是缩放的话，除了flex我只能inline-bloc然后设置每个元素的比例了

![神奇程序员-面试题1](../images/神奇程序员-面试题1.png)

###### 什么是BFC

- BFC是使用容器实现盒子隔离，是一块独立的渲染区域，用这个特性包含浮动元素，也就解决浮动导致元素塌陷的问题

- 当然，专业解释叫块状格式化上下文

- BFC是一种机制，需要条件才会触发，而大概有几种条件可以触发

	1. body根元素，这个必较少用，但是这是一个独立盒子渲染

	2. 浮动元素，也就是例如float，因为浮动能触发，所以才能用这个方式实现

	3. 绝对定位元素，abstract、fixed，绝对定位也是独立渲染

	4. display为inline-block、table-cells、flex

	5. overflow值为hidden、auto、scroll

> 简单总结就是脱离文档流的元素、非块级盒子的块级容器、还有overflow不为visible的块级盒子

- BFC也可以解决块级元素margin上下重叠问题

- 简单的操作就是再父级元素加`overflow: hidden`，或父元素浮动、父元素绝对定位等触发BFC实现容器隔离

###### 原型和原型链

###### 3道考察js执行顺序的题，考察面试者对eventLoop的理解程度

###### 手写代码题，给了一个树形json结构数据，让写出深度优先搜索的代码

###### 如果不用websocket，你还有什么办法实现实时消息接收？

> [面试官：除了 WebSocket 你还知道哪些实现双向即时通信的方法？](https://zhuanlan.zhihu.com/p/358687636)

###### 消息过多时，dom元素会变多，用户浏览消息时会感受到卡顿，这个问题你会怎么解决？

- 必较简单的就是分页

- 细节层面。减少事件监听，分批次获取数据分批次渲染

- 根源性解决卡顿问题。可以重复利用DOM结构，创建虚拟列表，只渲染可视区域

```bash
# 渲染10万条DOM
1. 列表中固定只显示少量的数据，比如60条
2. 在列表滚动的时候不断的去插入删除dom，或只是修改DOM的值实现DOM的复用
3. startIndex、endIndex，不断的改变这个值来获取最新的显示列表，并且计算控制滚动条位置
4. paddingTop、paddingBottom撑开容器的滚动区域
```

###### 一口井，深7米，蜗牛白天爬4米，晚上掉1米，请问蜗牛需要多久能从井里爬出来？

- 第二天就爬出来了，第二天白天直接爬完7米

###### 页面更新，vue底层是如何响应的？

- 首先是追踪变化的逻辑。Vue使用ES5的Object.definedProperty的getter/setter方法实现对数据的拦截，这个拦截针对的是基本数据类型，对象需要另作处理，Vue3已经实现ES6的proxy实现对象数据拦截，解决了这一漏洞。然后通过这样的getter/setter拦截可是实现数据变更的追踪，在属性被修改的时候通知变更。同时Vue实例还有个watcher在渲染的过程把对应需要的变量记录，但属性变更的时候就notify通过watcher，把对应涉及渲染的变量组件进行重新触发渲染

- Vue对属性双向绑定需要在data中定义，而对象内部属性的变更(添加、修改和删除)是无法被双向绑定感知的，因为没有对属性进行getter/setter处理，所以针对对象内部属性的变更需要另作处理，也就是Vue提供了语法糖实现响应式变更，$set、$delete，当然，时常我会直接修改对象的整个值，进而触发响应

- 对了对象，数组也是引用类型无法被响应，也就是数组长度变化而没有生成新的地址的话是不会被监听到的，这个时候可以用$set方法对数组进行变更，也可以splice等原生数组函数的方法，因为会触发地址变更

- 每一次的变更夺回将变更推送到渲染队列，并且如果一次事件循环内多次触发响应，这些变更会被推入同一个渲染列表中，在缓存中去除重复数据操作，这也就是diff算法，虚拟DOM技术实现对Vue快速响应渲染的优化，一次一次的事件循环节点中，Vue渲染队列都会在渲染之前实现数据处理，剩下的留到下一次循环，对于这一点$nextTick这个函数就是让数据留到这一次DOM渲染完成后的操作

###### 说一下vue3和vue2的区别它做了哪些优化？

- 首先就是proxy。解决Object.definedProperty对象属性拦截的问题，解决了引用类型响应的问题

- typeScript。严格类型系统语言实现，这是Vue3表面最大的变化，语法层面的变化，让Vue更加严谨，声明式转为类式写法，貌似也解决了高阶函数实现的问题，也让Vue更好的支持大规模应用开发

- 对虚拟DOM进行了优化，较大提高了diff算法性能，看说是突破了瓶颈

- 更小的包。压缩了包的大小

- 优化架构和解耦，这是不知道优化了哪里

> 核心了解就是三个，proxy代理拦截、typescript语法变更、虚拟DOM优化

###### diff算法是如何比对新旧虚拟dom树节点的？

###### 有2个组件，Component A、Component B，每个组件里都有一个div，div下面有个span，A组件里span的值是a，B组件里span的值是b。那么这两个组件是相等吗？请说出原因

###### 说一下http的两种缓存，详细介绍下


> 参考：[我离职了](https://juejin.cn/post/6956728664562073630)
