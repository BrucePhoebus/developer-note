# 神奇的程序员-面 6 终上岸

### 首先给个个人评价

- 首先遇到这种环境肯定是很伤感的，一大堆麻烦事，但是他能意识到环境的变化，并作出改变，实际上已经跑赢你一部分人了，给自己带来更多机会

- 当然，很遗憾的是他曾经不努力只有大专学历，让我想到自己曾经的不够努力，实在是让人很伤感，在这个这么内卷的时代，不够努力的人，这苦果够吃一辈子

- 当然，他很幸运，因为他懂得努力，技术上的努力虽然让他够不着大厂，但是还是有很多小厂的机会，这个时代还是有很多机会的，就是越小的公司坑越多，到了这个年龄，我们越来越追求良好的环境，他也找到了一个合适的，这是他努力的成功，祝福他

> 不过最后想说，我们很多人处于一个不是很良好的环境，我们经常不懂得培养良好的习惯，良好的技术习惯，良好的思维习惯，良好的能力系统，这是或许我们和那些人最大的差距吧，可惜这种差距是最难解决的，只是，如果没有这种意识，那永远也没有解决的可能，希望我们每个人都能懂得，都能寻找到一些

### 面试题学习

###### vue 源码

- 简单看过一些源码，也看过一些相关的教学视频，对 Vue 的初始化到构建挂载等一些回调逻辑，但是并没有深入细节

- 也就是没有专门研究

###### vue 的组件化，用到哪些技术点，平时是怎么组件化开发的

- 关于组件化的思考，我一般对通用模块都会考虑抽离出一些组件

- 平时主要分为业务组件和功能组件，比例都差不多吧

- 例如功能组件，会抽离全局的分页组件、table 组件，这些都是业务上常用的一些组件，这些功能组件抽离主要是规范项目一致性，也方便维护。功能组件一般考虑多个功能模块使用时抽离的通用组件，例如表单这类，例如列表这类，例如一些 echart 图，例如一些选择树组件，多数都有实现过

- 业务组件一本是抽离复杂页面的一个块，蕴含独立的业务逻辑，他们也是单文件组件，也可以独立存在，或者依赖输入参数，当然，作为子组件，一般都是有 props 进行参数传递的

- 至于组件抽离的实际，一般要根据业务场景，过于小的项目，例如 echart 图，可能就用到一两个地方，无所谓抽离，例如表单列表分页这类常用则一般都会抽离，当然，很多时候是直接拿以前的进行细微改造

- 关于组件化的技术，浅层组件交互常用`props`和`$emit`，然后之前还有用过`eventBus`、`$emit/$on`中间车间多兄弟组件通讯 ，至于组件库式的传递听说`provide/inject`进行隔代深层次的组件传递，简单用过，但是并没有深度实践

- 平时基本上就是简单是父组件参数传递和接受子组件的通知回调

- 至于`parent/children`等其余通信方法比较少用

> 还有那些呢？

1. 插槽

   - 预留位置

   - 使用插槽可以减少组件依赖，例如不用状态控制，进一步解耦的组件化方式

   - 例如使用作用域插槽可以轻易取得子组件数据使用

###### Vue3.0 和 Vue2.0 的区别

- 语法的改变，使用了类式语法，使用了 typescript，暴露 createApp 方法进行 Vue 实例化

- 改为使用`proxy`进行响应式处理，解决了`Object.definedProperty`带来的对象数组等无法良好监听响应的问题

- 主要是这两方面，当然，还有使用 setup 等这些东西，以及虚拟 DOM 算法优化，自定义渲染器等等，这些就不熟了

- 这里细点：[深圳市洲明科技股份有限公司](知识笔记/大前端/面试/面试经验之道/深圳市洲明科技股份有限公司.md)

###### 为什么 Vue3.0 使用 proxy 性能更好呢？

- proxy 是 es6 的语法，具有更强大的功能，是直接拦截对象，而不是拦截属性，并且提供很多拦截方法，直接解决了 2.0 存在的对象处理问题，提高了性能

- 当然也是有负面作用的，兼容性相比 es5 的`Object.definedProperty`差，但是这个技术将持续被厂家兼容，不断的进行性能优化

###### proxy 的缺点是什么？为什么比`Object.definedProperty`快

- 缺点主要是兼容性的问题，使用 es6 的语法，对一些环境的兼容性可能存在问题，也就是对兼容性比较强的需求的项目可能不太方便使用这个技术，或需要特殊转码解决，对很多企业并不是多么好的选择，暂时

- 快的原因是，解决了原本`Object.definedProperty`的问题，原本`Object.definedProperty`监听属性而无法直接监听对象内部变化，需要对对象内部进行复杂监听处理，例如数组需要重新创建来触发监听，虽然提供了`$set/$delete`语法处理，但是实际上也是消耗性能的，而 proxy 则是原生支持直接监听对象的变更

###### `Object.definedProperty`是什么样的机制

- 首先`Object.definedProperty`可以直接在一个对象上操作这个存在亦有的对象或熟悉，增删查改，或设置对象/属性的属性，例如设置内部属性不可改(默认就是不可改的)，可以通过`get()/set()`方法操作

- 那么 Vue 就是通过这个方式实现对数据的监听回调，也就是双向绑定

- 当然，这里面操作的是一个个属性，也就是箭头的是一个个属性，如果想要监听一个对象，这个就做不到了，所以对这种情况 Vue 就需要另作处理了，例如递归出来，通过 hasOwnProperty 识别所有对象，然后对所有对象都判断处理一遍

- 那么很明显这就比较消耗性能了

###### Object.definedProperty 与 proxy 有那些区别

- 前者是监听一个个属性，而后者直接拦截对象，区别很大

###### vue3 打包按需引入如何做到，为什么 vue2 没有做到

Tree-Shaking 实现内部组件 ES 导出，这样内置组件实现按需引入

> [快速了解 vue3.0 新特性](https://www.bilibili.com/read/cv6429077)

###### 你在 vue 项目做了哪些性能优化

1. 打包优化。拆分文件、代码压缩、gzip 压缩、抽离公共插件

2. CDN 加速。将部分静态资源使用 CDN 引入

3. 路由按需加载

4. 页面资源按需加载现实，图片懒加载

5. 浏览器缓存

6. 大数据量的分页和查询

7. v-if 和 v-show 的使用

> [手把手教你深入 Vue3.0(Vue-cli4)项目打包性能优化实践](https://blog.csdn.net/qq_36824777/article/details/106407846)

> [Vue 项目性能优化 — 实践指南（网上最全 / 详细）](https://zhuanlan.zhihu.com/p/78467131)

###### 有没有了解 http 缓存

- 知道可以进行资源是否缓存设置，`cache-control`，可以设置不缓存、缓存、缓存时间等

- 尤其是项目 token 设置的时候，可能需要设置缓存时间`Expires`

- 也有你协商缓存和硬性缓存这两个概念

- 时常在 Vue 项目中，会根据需要缓存的路由页面设置缓存，`keep-active`

- 这方面有了解，但是业务应用得少，就没有深入了，实际上是忘了

###### 硬性缓存对应的是那个 header 值

    只要缓存有效，就直接读取缓存数据

1. expires

2. cache-control

###### 说下协商缓存，协商缓存会在什么时候取得

- 协商缓存是由服务器确认资源是否可用，也就是浏览器会拿资源的请求头去找服务器验证有效性，无效则重新获取

- 这里面主要是判断`Last-Modified`或者`Etag`，如果服务器返回 304 则浏览器会直接读取缓存

> `Etag`是`HTTP1.1`为解决前者出现的一些问题来更精准的控制缓存

###### 有哪些资源的缓存策略，html、css、js 是怎么设置缓存

- 对不常变的资源可以手动修改版本/后缀实现资源更新

- 而对其余的资源也是后缀变更实现，不过一般工程化项目会直接使用 hash 作为后缀，实现项目更新，如果某种资源固定没有变化，hash 值也就不会变化，这个可以通过配置 webpack 插件打包处理

- 当然也可以使用 http 缓存实现，也就是对某些资源使用强缓存，需要变更的时候手动修改路径或后缀版本参数

- 而协商缓存是常见设置，或直接设置不缓存也是可以的

###### Vue 的插槽机制是怎么样的？如何使用？

- 相当于留一个位置，直接将 Vue 模板传进去，比起传参可以实现更加灵活的操作，也是一种灵活的组件思想，并且可以实现默认值替换功能

- 并且相当于一小块组件，由于是在父组件中使用，可以自由变量控制而不需要复杂的传参，也就是这个子组件将变数大的组件块用插槽填充，这样就不需要限定各自格式和传参接口，非常灵活

- 例如一个布局灵活多样的列表组件，将允许自定义的行使用插槽暴露，并且使用默认值，这样就允许默认使用标准化的列表，也可以让用户自定义使用，通过插槽语法，使用时替换默认插槽模板代码，就这么简单

###### 插槽有哪些 API？插槽的作用域

- 最简单是插槽直接使用 slot 标签实现，这是默认插槽

- 具名插槽是在一个组件有多个插槽的时候通过添加 attribute 属性 name 作为区分

- 作用域插槽。因为插槽实际上是将模板传到到子组件一起渲染，那么这个时候需要使用到父组件的变量的话就需要通过 v-bind 将参数注入进入，也就是相当于插槽的 prop 绑定上去，默认命名是`slotProps`。

> 作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数(slotProps)的函数里

###### 具名插槽如何使用？

- 子组件通过在元素上添加 slot 属性标明这是具名插槽，不加的则是默认插槽，然后父组件通过在 slot 插槽标签中 name 区分，对应不同名字的插槽

###### 自定义组件的双向绑定怎么写？

- 如 input 组件的双向绑定是对父组件 emit 进行通知，也就是通过 prop 和$emit这种通信回调可以实现双向绑定。如input change回调修改$emit 通知父组件，然后触发父组件修改

###### 父子组件如何通信，除了 emit 和 evenBus 外还有哪些？

- 主要用的就是 emit 和 evenBus 进行简单通信，听说常用于组件库开发无限传递通信的 provide/inject，当然还有 children 和 parent 父子通信以及 attrs/listeners 隔代通信等

- 全局通信实际上还有用过 Vuex，加个监听

###### Vue 双向绑定的 sync 有了解过？

- 这是一个 vue v-bind 的修饰符，也就是一种语法糖，是实现组件和外部数据的直接双向绑定

- 以前我们是使用 emit 实现通知父组件更新的，例如 emit/on，也可以使用 update 这个修饰符，而现在直接可以使用 sync 这个修饰符达到同样的效果，而不需要 emit，相当于 update 的语法糖，又方便了，直接实现父子组件双向绑定

###### Vue 响应式对数组做了什么额外处理？

- 如果直接通过下标修改数组，Vue 是无法监听到的，而通过数组原生函数修改是可以监听到的，Vue 重写了数组原生函数，加了 notify 分发通知，实现变更监听，如果 splice 这个函数就做了触发分发的操作

- 还有提供了$set语法支持对数组的操作，这个$set 也支持对对象的修改，实际上是一个逻辑

###### 知道数组哪些 API 会改变原函数？

1. pop：弹出一个元素，也就删掉一节，直接修改原数组长度

2. push：添加一个元素，也就加上了一节，直接修改原数组长度

3. splice：添加或删除数组部分，返回被删除的部分，直接操作数组长度

4. shift：删除头部元素并返回，直接修改原数组长度

5. unshift：插入元素到头部。返回新数组长度，直接修改原数组长度

6. sort：排序，会改变原数组内容

7. reverse：翻转，直接修改原数组内容

8. fill：填充数组，批量覆盖或初始化数组，直接改变原数组内容

9. copyWithin：ES6 新增的数组函数，直接指定位置插入一段数组，可覆盖原来数组部分，即改变长度，也改变内容

###### 说说对解构的理解

- 首先常用的是接受对象数据的时候我们可以通过结构函数，将一个对象展开，甚至深层次展开，并明确声明赋值部分对象内部变量，包括 import 在引入一些文件的多个函数对象的时候也一般会用

- 同时这个结合三点展开一个对象，将一个对象浅拷贝到另一个对象，这里的对象包括大括号的对象，也还有数组，字符串实际上也被支持

- 解构，如同字面上就是解析，就是拆解，将一个对象拆解成多个属性，这个同时也可以自动转为符合的类型，例如对象转为数组，自动将内容 push 到数组中，这就是语法糖了，其次一一对应，这种支持让声明赋值更加精准明确，也要求传入的参数应该有这个字段，有一定的明确声明意义，当然用起来最重要是方便

###### 说一说剩余参数，它是如何使用的

- 剩余参数允许我们接受不定数量参数，并且表示为一个数组，以`...`语法标识该参数是剩余参数，接收之后的所有变量存储于当前变量

- 接收之后就是一个数组了，当作一个数组使用即可，也可以直接使用解构语法，当然这个跟脱了裤子放屁一样，剩余参数的目的本身就是接收不确定参数

- 其本质实现是用 arguments 接收参数然后转为数组存在

###### 解构时，如何给一个变量赋默认值？

- 额，这个解构场景是什么？是接收参数的时候？那直接在解构参数等于一个默认值即可，如果是一个新的变量，那就直接对原有变量冒号一个新的变量等于一个默认值

```js
const info = {
	name: 'zyk',
	age: undefined
}
let { name: nickName = '新变量默认值', age: '默认值' } = info
```

###### 你是怎么使用 Promise 的？

- 必较常见的使用是在需要异步等待的代码中 new 一个 Promise 实例，然后 then then 回调处理，当然有些时候使用`async/await`更优雅，同时并发的时候也会用到

###### 如何把一个请求封装成 Promise 方式？

- 很简单，例如 ajax，把 ajax 请求封装在 Promise 实例中，返回这个 promise 对象，如果 ajax 成功就 resolve，如果失败就 reject

###### then 可以接收什么回调，它可以接受失败回调？

- promise 的 then 接受 resolve 完结的回调，如果这次异步完成，无论执行是何结果都可以 then，只是对应 resolve 状态，失败回调也可以放到 then 另作处理，而常常 promise 的 catch 我们常常用 reject 状态完结，具体失败回调是放 catch 统一处理还是 resolve 进入 then 表示完结另作处理看具体业务

###### 在线聊天系统 - chat-system

> 参考学习：[在线聊天系统](https://gitee.com/gezi18/chat-system)

###### TypeScript 泛型，使用方式和场景

- 泛型在不同类上可以实现不同参数类型的实例，对应组件就是不同类型的组件，也就是实现组件重用

- 跟 Java 用的好像差不多，也就是标签符 T，在创建实例的时候使用不同类型创建，那么整体实例类型就不一样，同样使用在函数

- 例如我们创建集合存储处理数据，那么我们就可以通过泛型实现程序复用，一套程序实现可以创建多种类型集合

###### 如果接口返回 promise 类型的数据，你如何个用 TypeScript 声明它？

- 在声明文件定义期许返回类型的数据类型，然后再返回 promise 类型的函数中冒号声明 Promise 类型参数为这个期许类型(把这个对象放进去)

```js
declare namespace Service {　　
	interface login {
		id: string
		name: string
		date: Date
　}
}
export default function login(): Promise<Service.login> {
	return new Promise(resolve => {
		axios.get('url', param).then(res => {
			resolve(res);
		});
	});
}
```

###### 举一个你在项目中使用 typescript 泛型的例子

    没有用过

- 可以在模拟组件中使用

```ts
abstract class Component<T1, T2> {
	props: T1;
	state: T2;
	constructor(props: T1) {
		this.props = props;
	}
	abstract render(): string;
}

interface IMyComponentProps {
	val: number;
}

interface IMyComponentState {
	x: number;
}

class MyComponent extends Component<IMyComponentProps, IMyComponentState> {
	constructor(props: IMyComponentProps) {
		super(props);
		this.state = {
			x: 1,
		};
	}
	render() {
		this.props.val;
		this.state.x;
		return "<myComponent />";
	}
}
let myComponent = new MyComponent({ val: 1 });
```

###### 如何使用 typescript 的联合类型?

- 在声明返回值类型的时候或传入值类型的时候或上其他类型，标明可以不止一个类型

- 例如在字符串和数值类型一同处理的时候，可以允许这两种类型传入，当然一般返回类型应该是固定的，不一般的是异常处理结果需要返回非正常类型

###### 说一下 typescript 中的内置类型

- `Partial`。标记可选，这个常用，将类型 T 的所有属性标记为可选属性

- `Required`。标记必选，这个常用，将类型 T 的所有属性标记为必选属性

- `Readonly`。标记只读，这个常用，标记属性不能修改

- `Pick`。过滤属性，从某个类型中过滤出某个或某些属性

- `Record`。标记类型，标记对象属性或属性值的类型

- `Exclude`。移除属性，移除特定类型中的某些属性

- `Extract<T, U>`。交集属性，Exclude 的反向操作，去两者的交集属性

- `NonNullable`。排除 null 属性，排除类型为 null 或 undefined 的属性

- `ReturnType`。返回类型，这个常用，获取函数的返回类型

> 参考：[TypeScript 中的内置类型](https://blog.csdn.net/u014627807/article/details/108002767)

###### 说一下 typescript 中的 pick 类型?

- 过滤属性，从某个类型中过滤出某个或某些属性

```ts
// 通过pick语法获取对象的指定类型的属性内容
type person5 = Pick<Person, "name">;
// person5 === { name: string }
```

###### 如何使用 typescript 定一个一个对象类型?

```ts
private data: { [name: string]: DataModel };
this.data = {};
```

###### 说一下 typescript 中的 type 与 interface 的区别

- 都可以描述一个对象或函数，基本只是语法不同，也支持拓展

- 但是 type 可以声明基本类型别名、联合类型、元组等类型，可操作性还是比较大

- 而 interface 可以声明合并，算是一个小差异吧，而 OOP 我们主要用 interface，也一般用这个

- 普通项目尽量使用 interface，对于 OOP 项目在明确的时候是使用 interface，其余场景可以考虑用 type，例如定义 function

###### 说一下 typescript 中的交叉类型

- 交叉类型取的是并集，也就是拥有两个类型成员的所有属性

###### 聊一下 css，你用的什么布局多一点

- 我应该使用浮动自适应布局比较多，当然偶尔组件开发也会用到 flex 的布局方式，包括实际上经常用到的 element 的布局就是 flex 布局，当然只是用

> 很遗憾，我只选了一个最简单的解决方案，并且对其余方案没有都会

###### 说一下 flex 中，你常用的的属性?

1. 元素属性

- `order`。排序

- `flex-grow`。元素放大比例

- `flex-shrink`。元素缩小比例

- `flex`。flex-grow，flex-shrink 和 flex-basis 的简写

2. 容器属性

- `justify-content`。定义元素在主轴上的水平对齐方式，也就是水平属性，center 居中对齐，flex-start 左对齐，flex-end 右对齐，space-between 中间均分两边无间隙对齐，space-around 中间均分两边有间隙对齐

- `align-items`。定义元素在主轴上的垂直对齐方式，也就是垂直属性，center 上下居中对齐，flex-start 上对齐，flex-end 下对齐，stretch 未设置高拉满高填充，baseline 多元素以第一行文字为基准对齐

- `flex-wrap`。换行方式，normal 不换行，wrap 第一行在上方，wrap-reverse 第一行在下方

- `flex-direction`。主轴方向，row 从左到右水平方向，row-reverse 从右到左水平方向，column 从上到下垂直方向，column-reverse 从下到上水平方向

- `flex-flow`。flex-direction 属性和 flex-wrap 属性的简写形式

- `align-content`。多线轴对齐

> [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

###### flex 溢出换行用的哪个属性?

- flex-wrap

###### 主轴与交叉轴的方向用哪个属性定义?如何颠倒这些属性?

- flex-wrap: wrap-reverse; 不需要知道方向，属于针对容器的颠倒

###### 说一下 flex-grow 怎么使用?

- 按比例占据剩余空间，将空间填充

- 设定父元素 display 为 flex 布局，在子元素设定 flex-grow 大小占据比例值

###### 说一下 css 的选择器都有哪些以及优先级?

1. id 选择器

2. class 选择器

3. 元素选择器

4. 属性选择器

5. 通配符

6. 伪类选择器

7. 组合选择器

   - 后代选择器

   - 子选择器

   - 直接兄弟选择器

   - 兄弟选择器

> 优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器

###### css 实现 10 列布局如何做?

- 可以用 CSS3 的 columns 属性多列布局

- 可以用 flex 布局的`flex-wrap`不换行 10 列一排

> 让文本像报纸一样自动多列显示，可以轻松实现瀑布流布局

###### 如何实现通过不同的类名，来控制它的均分?比如我传 col2，那么这- - -列就占 20%，col3 就占 30%

- flex 布局，按比例设置 col2 的 flex-grow

- 直接设置 col2 的比例就是 20%，然后内部 100%填充

###### 让元素横着排列，除了 flex 还可以怎么做?

- 如果允许滚动条，那就是父元素设置 white-space 为 normal

- 如果是缩放的话，除了 flex 我只能 inline-bloc 然后设置每个元素的比例了

![神奇程序员-面试题1](../images/神奇程序员-面试题1.png)

###### 什么是 BFC

- BFC 是使用容器实现盒子隔离，是一块独立的渲染区域，用这个特性包含浮动元素，也就解决浮动导致元素塌陷的问题

- 当然，专业解释叫块状格式化上下文

- BFC 是一种机制，需要条件才会触发，而大概有几种条件可以触发

  1.  body 根元素，这个必较少用，但是这是一个独立盒子渲染

  2.  浮动元素，也就是例如 float，因为浮动能触发，所以才能用这个方式实现

  3.  绝对定位元素，abstract、fixed，绝对定位也是独立渲染

  4.  display 为 inline-block、table-cells、flex

  5.  overflow 值为 hidden、auto、scroll

> 简单总结就是脱离文档流的元素、非块级盒子的块级容器、还有 overflow 不为 visible 的块级盒子

- BFC 也可以解决块级元素 margin 上下重叠问题

- 简单的操作就是再父级元素加`overflow: hidden`，或父元素浮动、父元素绝对定位等触发 BFC 实现容器隔离

###### 原型和原型链

- 根结要梳理好 Object 和 Function 的互相继承问题，实际上他们都继承于 Object.prototype，这两者的关系确认清楚，基本上原型链就那样，因为 Object 是由 Function 构造生成，而 Function 又是继承 Object，它们即使对象也是函数

- 一切的根是 null，从 Object.prototype.**proto**是 null 可以看出，最后 Object 原型指向最终的根 null 作为终结

- 而包括 Function 还有其他内置对象都是二级继承于 Object 对象，但是 Function 也作为顶级函数生成 Object，所以终结问题是这两者的关系

- 不过原型和原型继承实现的原型链可以简单理解，就是对象的原型指向串联成原型链，每个对象都有个原型对象，实现对象继承，其中有个原型属性**proto**，这个原型属性是浏览器用来记录原型属性方法的，而 prototype 则是开放给开发者用的，通过这个原型继承的关联，一个对象关联上一层对象，实现原型链。其中 Object.prototype 是一切的父，所有的对象(引用类型)都继承于它

###### 3 道考察 js 执行顺序的题，考察面试者对 eventLoop 的理解程度

- 事件循环考虑的是浏览器处理 js 程序的任务队列逻辑，核心又是宏任务和微任务的优先级逻辑

###### 手写代码题，给了一个树形 json 结构数据，让写出深度优先搜索的代码

```js
// 深度遍历, 使用递归
function getName(data) {
	const result = [];
	data.forEach((item) => {
		const map = (data) => {
			result.push(data.name);
			data.children && data.children.forEach((child) => map(child));
		};
		map(item);
	});
	return result.join(",");
}
const data = [
	{
		name: "a",
		children: [
			{ name: "b", children: [{ name: "e" }] },
			{ name: "c", children: [{ name: "f" }] },
			{ name: "d", children: [{ name: "g" }] },
		],
	},
	{
		name: "a2",
		children: [
			{ name: "b2", children: [{ name: "e2" }] },
			{ name: "c2", children: [{ name: "f2" }] },
			{ name: "d2", children: [{ name: "g2" }] },
		],
	},
];
console.log(getName(data));
```

###### 如果不用 websocket，你还有什么办法实现实时消息接收？

> [面试官：除了 WebSocket 你还知道哪些实现双向即时通信的方法？](https://zhuanlan.zhihu.com/p/358687636)

###### 消息过多时，dom 元素会变多，用户浏览消息时会感受到卡顿，这个问题你会怎么解决？

- 必较简单的就是分页

- 细节层面。减少事件监听，分批次获取数据分批次渲染

- 根源性解决卡顿问题。可以重复利用 DOM 结构，创建虚拟列表，只渲染可视区域

```bash
# 渲染10万条DOM
1. 列表中固定只显示少量的数据，比如60条
2. 在列表滚动的时候不断的去插入删除dom，或只是修改DOM的值实现DOM的复用
3. startIndex、endIndex，不断的改变这个值来获取最新的显示列表，并且计算控制滚动条位置
4. paddingTop、paddingBottom撑开容器的滚动区域
```

###### 一口井，深 7 米，蜗牛白天爬 4 米，晚上掉 1 米，请问蜗牛需要多久能从井里爬出来？

- 第二天就爬出来了，第二天白天直接爬完 7 米

###### 页面更新，vue 底层是如何响应的？

- 首先是追踪变化的逻辑。Vue 使用 ES5 的 Object.definedProperty 的 getter/setter 方法实现对数据的拦截，这个拦截针对的是基本数据类型，对象需要另作处理，Vue3 已经实现 ES6 的 proxy 实现对象数据拦截，解决了这一漏洞。然后通过这样的 getter/setter 拦截可是实现数据变更的追踪，在属性被修改的时候通知变更。同时 Vue 实例还有个 watcher 在渲染的过程把对应需要的变量记录，但属性变更的时候就 notify 通过 watcher，把对应涉及渲染的变量组件进行重新触发渲染

- Vue 对属性双向绑定需要在 data 中定义，而对象内部属性的变更(添加、修改和删除)是无法被双向绑定感知的，因为没有对属性进行 getter/setter 处理，所以针对对象内部属性的变更需要另作处理，也就是 Vue 提供了语法糖实现响应式变更，$set、$delete，当然，时常我会直接修改对象的整个值，进而触发响应

- 对了对象，数组也是引用类型无法被响应，也就是数组长度变化而没有生成新的地址的话是不会被监听到的，这个时候可以用$set 方法对数组进行变更，也可以 splice 等原生数组函数的方法，因为会触发地址变更

- 每一次的变更夺回将变更推送到渲染队列，并且如果一次事件循环内多次触发响应，这些变更会被推入同一个渲染列表中，在缓存中去除重复数据操作，这也就是 diff 算法，虚拟 DOM 技术实现对 Vue 快速响应渲染的优化，一次一次的事件循环节点中，Vue 渲染队列都会在渲染之前实现数据处理，剩下的留到下一次循环，对于这一点$nextTick 这个函数就是让数据留到这一次 DOM 渲染完成后的操作

###### 说一下 vue3 和 vue2 的区别它做了哪些优化？

- 首先就是 proxy。解决 Object.definedProperty 对象属性拦截的问题，解决了引用类型响应的问题

- typeScript。严格类型系统语言实现，这是 Vue3 表面最大的变化，语法层面的变化，让 Vue 更加严谨，声明式转为类式写法，貌似也解决了高阶函数实现的问题，也让 Vue 更好的支持大规模应用开发

- 对虚拟 DOM 进行了优化，较大提高了 diff 算法性能，看说是突破了瓶颈

- 更小的包。压缩了包的大小

- 优化架构和解耦，这是不知道优化了哪里

> 核心了解就是三个，proxy 代理拦截、typescript 语法变更、虚拟 DOM 优化

###### diff 算法是如何比对新旧虚拟 dom 树节点的？

- 只有选择器相同且key相同才是同一个虚拟节点，此时diff算法才会对这个虚拟DOM节点进行对比

- Vue在渲染页面时是通过render函数将更新渲染到虚拟DOM树，此时便可能产生新旧节点，这个新旧节点便是根据选择器和key值判断，相同则是同一个节点的更新，那便会进行合并处理，最后patch到真实DOM上去实现视图更新

- 真实的例子例如list列表使用到的v-for循环，所以要加KEY方便diff算法区别，还有相同元素的切换只有内容和key不同的话，也会很方便进行替换

###### 有 2 个组件，Component A、Component B，每个组件里都有一个 div，div 下面有个 span，A 组件里 span 的值是 a，B 组件里 span 的值是 b。那么这两个组件是相等吗？请说出原因

- 组件不是独立封装的？怎么可能是相等，它们应该是独立的两个对象，不应该存在交叉，即使内部存在相同的对象，那也是内部引用了相同的对象，但是整体对象依旧是保存在两个不同的对象之中

- 组件的实例化应该是创建两个独立的对象，这个从data对象是通过函数返回属性可以知道，避免两个组件互相污染，哪怕它们html和css是一样的，甚至变量名也是一样的，但是他们js依旧是存储在两个对象之中，不允许污染

###### 说一下 http 的两种缓存，详细介绍下

- 强制缓存和协商缓存

- 强制缓存的话，如果读取本地缓存未过期，则直接读取而不需要向服务器询问，关键点在于设置缓存的过期时间，对于这种缓存的更新只能更新引用文件后缀实现更新，因为它不会询问服务器是否更新，而是直接读取相应的缓存文件

- 协商缓存则是判断缓存文件是否过期后，都会询问服务器进行文件对比，只是对比没有变更后才读本地文件，而变更后则重新获取服务器上的文件

- 详细，略

> 参考：[我离职了](https://juejin.cn/post/6956728664562073630)
