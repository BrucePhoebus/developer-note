# 神奇的程序员-面6终上岸

### 首先给个个人评价

- 首先遇到这种环境肯定是很伤感的，一大堆麻烦事，但是他能意识到环境的变化，并作出改变，实际上已经跑赢你一部分人了，给自己带来更多机会

- 当然，很遗憾的是他曾经不努力只有大专学历，让我想到自己曾经的不够努力，实在是让人很伤感，在这个这么内卷的时代，不够努力的人，这苦果够吃一辈子

- 当然，他很幸运，因为他懂得努力，技术上的努力虽然让他够不着大厂，但是还是有很多小厂的机会，这个时代还是有很多机会的，就是越小的公司坑越多，到了这个年龄，我们越来越追求良好的环境，他也找到了一个合适的，这是他努力的成功，祝福他

> 不过最后想说，我们很多人处于一个不是很良好的环境，我们经常不懂得培养良好的习惯，良好的技术习惯，良好的思维习惯，良好的能力系统，这是或许我们和那些人最大的差距吧，可惜这种差距是最难解决的，只是，如果没有这种意识，那永远也没有解决的可能，希望我们每个人都能懂得，都能寻找到一些

### 面试题学习

###### vue源码

- 简单看过一些源码，也看过一些相关的教学视频，对Vue的初始化到构建挂载等一些回调逻辑，但是并没有深入细节

- 也就是没有专门研究

###### vue的组件化，用到哪些技术点，平时是怎么组件化开发的

- 关于组件化的思考，我一般对通用模块都会考虑抽离出一些组件

- 平时主要分为业务组件和功能组件，比例都差不多吧

- 例如功能组件，会抽离全局的分页组件、table组件，这些都是业务上常用的一些组件，这些功能组件抽离主要是规范项目一致性，也方便维护。功能组件一般考虑多个功能模块使用时抽离的通用组件，例如表单这类，例如列表这类，例如一些echart图，例如一些选择树组件，多数都有实现过

- 业务组件一本是抽离复杂页面的一个块，蕴含独立的业务逻辑，他们也是单文件组件，也可以独立存在，或者依赖输入参数，当然，作为子组件，一般都是有props进行参数传递的

- 至于组件抽离的实际，一般要根据业务场景，过于小的项目，例如echart图，可能就用到一两个地方，无所谓抽离，例如表单列表分页这类常用则一般都会抽离，当然，很多时候是直接拿以前的进行细微改造

- 关于组件化的技术，浅层组件交互常用`props`和`$emit`，然后之前还有用过`eventBus`、`$emit/$on`中间车间多兄弟组件通讯 ，至于组件库式的传递听说`provide/inject`进行隔代深层次的组件传递，简单用过，但是并没有深度实践

- 平时基本上就是简单是父组件参数传递和接受子组件的通知回调

- 至于`parent/children`等其余通信方法比较少用

> 还有那些呢？

1. 插槽

	- 预留位置

	- 使用插槽可以减少组件依赖，例如不用状态控制，进一步解耦的组件化方式

	- 例如使用作用域插槽可以轻易取得子组件数据使用

###### Vue3.0和Vue2.0的区别

- 语法的改变，使用了类式语法，使用了typescript，暴露createApp方法进行Vue实例化

- 改为使用`proxy`进行响应式处理，解决了`Object.definedProperty`带来的对象数组等无法良好监听响应的问题

- 主要是这两方面，当然，还有使用setup等这些东西，以及虚拟DOM算法优化，自定义渲染器等等，这些就不熟了

- 这里细点：[深圳市洲明科技股份有限公司](知识笔记/大前端/面试/面试经验之道/深圳市洲明科技股份有限公司.md)

###### 为什么Vue3.0使用proxy性能更好呢？

- proxy是es6的语法，具有更强大的功能，是直接拦截对象，而不是拦截属性，并且提供很多拦截方法，直接解决了2.0存在的对象处理问题，提高了性能

- 当然也是有负面作用的，兼容性相比es5的`Object.definedProperty`差，但是这个技术将持续被厂家兼容，不断的进行性能优化

###### proxy的缺点是什么？为什么比`Object.definedProperty`快

- 缺点主要是兼容性的问题，使用es6的语法，对一些环境的兼容性可能存在问题，也就是对兼容性比较强的需求的项目可能不太方便使用这个技术，或需要特殊转码解决，对很多企业并不是多么好的选择，暂时

- 快的原因是，解决了原本`Object.definedProperty`的问题，原本`Object.definedProperty`监听属性而无法直接监听对象内部变化，需要对对象内部进行复杂监听处理，例如数组需要重新创建来触发监听，虽然提供了`$set/$delete`语法处理，但是实际上也是消耗性能的，而proxy则是原生支持直接监听对象的变更

###### `Object.definedProperty`是什么样的机制

- 首先`Object.definedProperty`可以直接在一个对象上操作这个存在亦有的对象或熟悉，增删查改，或设置对象/属性的属性，例如设置内部属性不可改(默认就是不可改的)，可以通过`get()/set()`方法操作


- 那么Vue就是通过这个方式实现对数据的监听回调，也就是双向绑定

- 当然，这里面操作的是一个个属性，也就是箭头的是一个个属性，如果想要监听一个对象，这个就做不到了，所以对这种情况Vue就需要另作处理了，例如递归出来，通过hasOwnProperty识别所有对象，然后对所有对象都判断处理一遍

- 那么很明显这就比较消耗性能了

###### Object.definedProperty与proxy有那些区别

- 前者是监听一个个属性，而后者直接拦截对象，区别很大

###### vue3打包按需引入如何做到，为什么vue2没有做到

Tree-Shaking实现内部组件ES导出，这样内置组件实现按需引入

> [快速了解vue3.0新特性](https://www.bilibili.com/read/cv6429077)

###### 你在vue项目做了哪些性能优化

1. 打包优化。拆分文件、代码压缩、gzip压缩、抽离公共插件

2. CDN加速。将部分静态资源使用CDN引入

3. 路由按需加载

4. 页面资源按需加载现实，图片懒加载

5. 浏览器缓存

6. 大数据量的分页和查询

7. v-if和v-show的使用

> [手把手教你深入Vue3.0(Vue-cli4)项目打包性能优化实践](https://blog.csdn.net/qq_36824777/article/details/106407846)

> [Vue 项目性能优化 — 实践指南（网上最全 / 详细）](https://zhuanlan.zhihu.com/p/78467131)

###### 有没有了解http缓存

- 知道可以进行资源是否缓存设置，`cache-control`，可以设置不缓存、缓存、缓存时间等

- 尤其是项目token设置的时候，可能需要设置缓存时间`Expires`

- 也有你协商缓存和硬性缓存这两个概念

- 时常在Vue项目中，会根据需要缓存的路由页面设置缓存，`keep-active`

- 这方面有了解，但是业务应用得少，就没有深入了，实际上是忘了

###### 硬性缓存对应的是那个header值

	只要缓存有效，就直接读取缓存数据

1. expires

2. cache-control

###### 说下协商缓存，协商缓存会在什么时候取得

- 协商缓存是由服务器确认资源是否可用，也就是浏览器会拿资源的请求头去找服务器验证有效性，无效则重新获取

- 这里面主要是判断`Last-Modified`或者`Etag`，如果服务器返回304则浏览器会直接读取缓存

> `Etag`是`HTTP1.1`为解决前者出现的一些问题来更精准的控制缓存

###### 有哪些资源的缓存策略，html、css、js是怎么设置缓存

- 对不常变的资源可以手动修改版本/后缀实现资源更新

- 而对其余的资源也是后缀变更实现，不过一般工程化项目会直接使用hash作为后缀，实现项目更新，如果某种资源固定没有变化，hash值也就不会变化，这个可以通过配置webpack插件打包处理

- 当然也可以使用http缓存实现，也就是对某些资源使用强缓存，需要变更的时候手动修改路径或后缀版本参数

- 而协商缓存是常见设置，或直接设置不缓存也是可以的

![神奇程序员-面试题1](../images/神奇程序员-面试题1.png)

> 参考：[我离职了](https://juejin.cn/post/6956728664562073630)
