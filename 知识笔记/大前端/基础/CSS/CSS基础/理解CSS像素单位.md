# 理解CSS像素单位

## 概述

#### CSS主要有哪些单位？

	px、rem、em

###### px

	PX是Pixel的缩写，单位名称为像素，也就是说px是组成屏幕图像的最小独立元素

* 像素是相对于显示器屏幕分辨率而言的，通常被当作最精准的绝对单位(严格上说不是：官方考虑到观看不同设备显示屏时，使网页设计出的某一图形的显示大小在人眼中的观看效果差不多，而定义的一个相对值，即人以一臂之遥观看96DPI的显示屏的角度，大概就是利用透视的近大远小原理，照顾不同设备的最终观看效果)

**举例理解**

* 比如某网页图形设置为一固定的px值，在手机浏览器上显示是用直尺测大概1cm，但是同样在不缩放情况下，电脑显示屏测量可能就是1.5cm左右，如果是打印机打印出来的话也许就是2cm左右了

###### em

	em是emphasize的缩写，单位名称为相对长度单位，em的大小是相对于所在元素的font-size值的倍数，如果当前元素没有设置font-size就会根据继承，一层一层往父元素找
	em是灵活可拓展的单位，也就是相对单位，由浏览器转为像素值，具体取决于设计中的字体大小设置

**em 单位如何转换为像素值？**

	当使用em单位时，像素值将是em值乘以使用em单位的元素的字体大小

* 比如

	* 父元素字体16px，子元素设置1em，也可以理解为100%，那么子元素也是16px，同样，2em就是200%，32px，也可以是小数0.2em，1.5em等等

	* 如果一个 div 有 18px 字体大小，10em 将等同于 180px，即 10 × 18 = 180

``` css
.temp-em {
	/* 不一定是要父元素 */
	font-size: 18px;
	/* 浏览器会自动计算转换为 180px */
	padding: 10em;
}
```

!> 有一个比较普遍的误解，认为 em 单位是相对于父元素的字体大小。实际上，根据W3标准 ，它们是相对于使用em单位的元素的字体大小，至于为什么有时候会使用父元素的字体大小？是因为当前元素没有设置 font-size ，所以它会根据规则选择继承父元素的 font-size (一层一层往上找)

**em继承**

	每个元素使用em单位的时候会自动存在继承效果，也就是自动继承父元素的 font-size 值，而继承效果只能被明确的字体单位覆盖，比如px、vw...

* 使用`em`单位的元素字体大小默认根据它们来定，但是该元素可能继承其父元素的字体大小，而父元素又继承其父元素的字体大小，等等。。。 因此，以`em`为单位的元素字体大小可能会受到其任何父元素的字体大小影响。

**例如：**

* 继承根的字体大小：如果我们的根元素字体大小为 16px，一个子元素 div 里面padding值为 1.5em，该 div 将从根元素继承字体大小 16px。 因此padding会被浏览器转换成 24px，即 1.5 x 16 = 24

* 继承父元素，父元素再继承根：我们包裹一层 div 继承根元素字体大小 16px ，并乘以它自己的 1.5em 的字体大小。这将设置包裹 div 字体大小为 24px，即 1.5 x 16 = 24

* 直接继承父元素：直接包裹一层父元素，父元素设置`font-size`值为20px，那么当前元素会直接继承这个父元素的字体大小值，1.5em其padding值现在等于 30px，即 1.5 x 20 = 30

> 所以在使用em的时候可能一不小心就继承错了(也就是难追踪)，不过使用CSS预处理嵌套语法的时候也比较容易用，如果复杂项目还是直接使用rem感觉比较好

!> 如果没有设置`font-size`值，浏览器会一层一层往上找，一直找到根html有个默认的`font-size`值，好像浏览器默认值是`16px`

###### rem

	类似于em，但rem是相对于根元素html设置相对长度单位
	rem跟em一样，也是灵活可拓展的单位，也就是相对单位，由浏览器转为像素值，具体取决于设计中的字体大小设置

**那么rem 单位如何转换为像素值？**

	当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。根元素字体大小乘以当前元素的 rem 值

* 例如

	* 用css标签选择器给html标签设置字体尺寸font-size大小为20px，那么文档中的每个1rem就代表20px，1.5em代表30px，以此类推

	* 根元素的字体大小为：16px，10rem 将等同于 160px，即 10 x 16 = 160

``` css
/* 在根处(html)设置rem的相对父的大小 */
.html {
	font-size: 16px;
}
.temp-rem {
	/* 浏览器会自动根据根的 font-size 计算转换为 180px */
	padding: 10rem;
}
```


> 这些都是浏览器自动根据`根`的`font-size`进行计算的

#### 其它单位

* pt

	* pt是Point的缩写，单位名称为点，是绝对长度单位
	* 1in = 2.54cm = 25.4 mm = 72pt = 6pc

* pc

	* 派卡(Pica)，绝对单位长度，相当于我国新四号铅字的尺寸
	* * 1in = 2.54cm = 25.4 mm = 72pt = 6pc

* in(英寸Inch)，cm(厘米Millimeter)，mm(毫米Centimeter)

	* 这些在生活中是物体测量单位，但是在CSS中默认设置1in=96px，跟px存在等比关系，具体性质跟px类，所以因为这样，我们一般都使用px
	* 1in = 2.54cm = 25.4 mm = 72pt = 6pc

* dpi, ppi

	* dpi(dot per inch)，即每英寸多少点，是针对打印机的一个概念，点可以理解为墨点

	* ppi(pixel per inch)，即每英寸多少像素，是针对显示器的概念，开发中一般关心显示器问题，所以一般认为dpi和ppi是同一个概念

* dpr

	* dpr(device pixel ratio)，即物理像素与独立像素的比例
		
		* 物理像素也叫设备像素，屏幕显示图像都是由很多个像素点组成，屏幕出厂时本身带的点阵数就是它的物理像素
		* 而独立像素，又叫逻辑像素，或者css像素，顾名思义，逻辑嘛，当然是独立于物理的概念，大小没有固定实际值，也是前面提到的css里面的1px；其中逻辑像素可以通过js代码获取，screen.width获取逻辑像素宽度，screen.height是高度
	
	* dpr可以通过devicePixelRatio这个全局属性获取，现在的新一些的安卓智能手机一般这个比例是3，电脑的一般是1，iphone、iPad一般是2

	* 现在来说设备像素的获取，并没有直接的获取方法，所以可以通过dpr乘以逻辑像素的方法获取

``` js
var logicWidth = screen.width;
var logicHeight = screen.height;
var dpr = devicePixelRatio;
var deviceWidth = logicWidth * dpr;
var deviceHeight = logicHeight * dpr;
// 输出逻辑像素
console.log('逻辑像素：' + logicWidth + 'x' + logicHeight);
// 输出设备像素
console.log('物理像素：' + deviceWidth + 'x' + deviceHeight);
```

> dpr为1，说明一个css像素块由1x1个物理像素块来显示，也就是一个物理像素，如果为2，则是一个css像素由2x2个物理像素来显示，也就是4个像素块，以此类推；dpr的存在就是为了是小尺寸设备屏幕显示出高画质图形，细节更高就更清晰了

#### 浏览器设置 HTML 元素字体大小的影响

	除了考虑继承、浏览器默认等因素，我们还要考虑用户偏好方面的问题，因为存在浏览器设置问题，而当前浏览器基本都支持用户进行各种偏好设置
	其中一个就包括字体大小的设置，如果用户修改常规设置，那么就可能存在网页显示变形的问题，这都是我们需要考虑到的

* 默认情况下浏览器通常有字体大小 16px，但这可以被用户更改为从 9px 到 72px的任何值

	* 根 html 元素将继承浏览器中设置的字体大小，除非显式设置固定值去覆盖，所以 html 元素的字体大小虽然是直接确定 rem 值，但字体大小可能首先来自浏览器设置，因此浏览器的字体大小设置可以影响每个使用 rem 单元以及每个通过 em 单位继承的值

* 没有设置 HTML 字体大小时，浏览器设置起作用

	* 除非重写，否则它将继承浏览器默认设置的字体大小，也就是我们用户默认使用的浏览器字体大小设置：`font-size: 16px;`，这是在我们不直接在html中显式的写指定`font-size`大小的情况下。在这种情况下 10rem 等于 160px，即 10 x 16 = 160

	* 但是如果用户将浏览器默认字体大小调为18px，根字体大小变成 18px：现在 10rem 转换为 180px，即 10 × 18 = 180

> 所以存在用户修改浏览器默认设置的情况，如果我们使用浏览器默认，那么我们就需要针对做适配兼容处理(否则页面可能变形)，但是如果我们显式指定大小，那么用户便没有办法设置，这样用户体验不好，当前基本没人这样做。。。所以我们要考虑的是怎么解决用户修改的情况下做兼容

> 当然上面说的设置修改是修改`html`的`font-size`，所以很多时候我们想得比较多的是rem，但是em也存在继承html的情况，所以我们一般也是需要考虑的，至于情况就跟rem差不多了。

#### rem VS em

	在自适应布局中，我们经常会看到或使用到rem或em作为元素大小单位，而rem是基于html元素的字体大小来决定，而em则根据使用它的元素的大小决定，那么具体它们有什么区别？使用场景方面有什么区别？

###### 先说说rem和em这种相对单位有什么好处

* 使用 em 和 rem 单位可以让我们的设计更加灵活，能够控制元素整体放大缩小，而不是固定大小。 我们可以使用这种灵活性，使我们在开发期间，能更加快速灵活的调整，允许浏览器用户调整浏览器大小来达到最佳体验。

###### 主要区别

	em 和 rem 单位之间的区别是浏览器根据谁来转化成px值，也就是我们理解了它们根据什么作为根就行了

* 从上面我们可以看出，em是使用当前元素的`font-size`值，如果没有设置，浏览器会一层一层往上找它的父元素(也就是它会继承父元素的字体大小)，直到找到根html有个默认设置，当然一般项目中肯定有设置的，不过这样就存在一个问题了：如果项目复杂，我们可能会存在多个`font-size`值的设置，如果不小心可能会存在继承错的问题(当然改起来应该不会牵扯太多，只是比较难维护)，而rem只有一个参考系：就是根html，所以rem在复杂项目上还是比较好的

	* 不过现在有CSS预处理，我们可以使用嵌套语法，这样我们使用em还是很方便的，基本不会有继承错的问题

**总结**

* rem 单位转换为像素值是由 html 元素的字体大小决定的，而em 单位转为像素值，取决于他们使用的字体大小

	* 但是`rem`字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位
	* 而使用em的元素字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位

###### 为什么使用rem单位？

	现在比较多的还是rem单位，明显rem单位在应用上还是有很大的优势效果的，因为我们要考虑到用户对浏览器的偏好设置

* `rem`单位提供最伟大的力量并不仅仅是他们提供一致尺寸而不是继承。相反，它给我们的一个途经去获取用户的偏好来影响网站中每一处使用rem的元素大小，不再是使用固定的 px 单位

> 使用 rem 单位的主要目的应该是确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小

**举例说明**

* 一个站点最初设计可以专注于最常见的默认浏览器中字体大小 16px，这种情况下我们看到的页面是普适的

![rem示例站点图1](../images/rem示例站点图1.png)

* 但是，通过使用 rem 单位，如果用户调整其字体大小，我们也能保证布局的完整性，使用较小的文本避免文本空间被压扁了

![rem示例站点图2](../images/rem示例站点图2.png)

* 如果用户缩小其字体大小，整个布局掉下来，空白区域中的文本也不会显得很无力，布局效果还存在

![rem示例站点图3](../images/rem示例站点图3.png)

> 用户会因为各种各样的原因更改字体大小设置，例如阅读放大字体，有各种各样的理由，也就是偏好设置了，容纳这些设置可以获得更好的用户体验，直接间接效果都不错

!> 注：鉴于良好的用户体验，我们要允许用户进行偏好设置，也就是我们要使用html默认字体大小，这样用户可以通过修改浏览器设置实现更好的用户体验，而我们需要做的就是实现更好的兼容布局效果的页面

###### 为什么使用 em 单位？

	上面说完rem的好处，但是em作为一个常用单位，也是很显然的使用它会有些不错的好处
	先说下：em 单位取决于一个font-size值而非 html 元素的字体大小。

!> em 单位的主要目的应该是：允许保持在一个特定的设计元素范围内的可扩展性

**示例说明**

	我们可能使用em 值设置导航菜单项的padding、 margin，line-height等值

1. 带有0.9rem 字体大小的菜单

![em示例说明图1](../images/em示例说明图1.png)

2. 带有1.2rem 字体大小的菜单

	通过这种方式，如果我们更改菜单的字体大小菜单项周围的间距将在剩余的空间按比例缩放

![em示例说明图2](../images/em示例说明图2.png)

## 应用

#### 实际应用场景

###### em使用场景

* 根据某个元素的字体大小做缩放而不是根元素的字体大小

	* 一般来说，我们需要使用 em 单位的唯一原因是缩放没有默认字体大小的元素

	* 例如：设计组件比如按钮，菜单和标题可能会有自己明确的字体大小，而当我们修改字体大小的时候，我们希望整个组件都适当缩放

> 通用属性这一准则将适用于在非默认字体大小的元素上的padding、 margin、 width、 height和line-height等值；通常不使用 em 单位控制字体大小，因为rem完全可以实现相同的效果，例如标题的缩放，rem具有更好的拓展性

* 使用 em 字体大小的下拉菜单

	* 因为我们有第二个级别的菜单项文本大小取决于第一级字体大小

* 按钮里面的字体图标

	* 字体图标的大小跟按钮的文本大小有关

> 也就是依赖于指定大小的控件的时候，存在上下层次依赖关系的时候，我觉得使用em更好，也就是类似上述例子，但是大部分情况下我们还是推荐使用 rem 单位的字体大小

###### rem使用场景

* 不需要 em 单位，并且根据浏览器的字体大小设置缩放的任何尺寸

	* 这几乎在一个标准的设计中占据了一切，包括heights，widths，padding，margin，border，font-size，shadows，几乎包括我们布局的每部分

> 一言蔽之：一切可扩展都应该使用 rem 单位

* 始终使用 rem 单位做媒体查询

	* 当使用 rem 单位创建统一可扩展的设计，媒体查询也应该是rem单位
	* 这将确保，无论用户浏览器的字体大小，媒体查询会对它作出反应和调整布局

!> 注：创建布局时，往往要以像素为单位更方便，但部署时应使用rem单位

###### 不使用某些单位场景

* 多列布局不使用 em 或 rem

	* 布局中的列宽通常应该是`%`，因此他们可以流畅适应无法预知大小的视区

> 但是单一列一般仍然应使用 rem 值来设置最大宽度

	这样即保持列了灵活性，可扩展，又能防止变得太宽了

``` css
.container {
    width: 100%;
    max-width: 75rem;
}
```

* 当元素应该是严格不可缩放的时候

	* 极少数情况下可能存在固定尺寸值的情况，而这种情况我们当然是考虑使用px解决问题

> 但很明显，这种情况如果出现缩放那么就很容易打破布局

###### px使用场景

	使用px像素还是存在的，也就是定死元素大小，这样很明显是不适合缩放/自适应场景的，并且如果存在缩放可能就会出现打破布局的情况，但是部分场景要求不高的时候使用px其实是没问题的

* 即使缩放也不影响布局的情况

	移动端/单页面有些情况是不要求自适应布局的，也就是即使缩放了也不影响效果，这种情况下，使用px就很直接，完全不需要考虑啥问题


> 参考：[rem与em的使用和区别详解](http://caibaojian.com/rem-vs-em.html) | [CSS单位与尺寸参数](https://knightyun.github.io/2019/01/27/css-px)
