# 认识JS模块化

## 概述

#### 什么是JS模块化

	模块就是实现特定功能的一组方法
	只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块（具备某种功能）
	现在的趋势是开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。

``` js
// 模块函数m1
function m1(){
	//...
}

// 模块函数m2
function m2(){
	//...
}
```

> m1和m2也可以组成一个模块，当然，这种写法会污染全局变量，所以我们一般会把它放进一个函数对象或匿名函数中

``` js
// 模块对象
var modelObject = {
	count: 0,
	// 模块函数m1
	function m1(){
		//...
	},
	// 模块函数m2
	function m2(){
		//...
	}
}

// 调用
modelObject.count = 4;
modelObject.m1();
```

> 这样就能实现函数封装，讲能实现制定功能的函数封装起来，又形成一个模块，而且实现了避免污染全局变量

> 当然，也可以实现为立即执行函数

``` js
var modelObject = (function(value) {
	count: 0,
	// 模块函数m1
	function m1(){
		//...
	},
	// 模块函数m2
	function m2(){
		//...
	}
})();
```

> 但是这种写法无法读取内部变量，当然可以传入一定的参数，不过输入固定后必定能得到一个准确的输出

**放大模式(继承)**

	当一些模块过大需要分成几部分或一个模块需要继承另一个模块的时候，可以使用"放大模式"实现

``` js
var module1 = (function(mod) {
	mod.func = function() {
		// 这是mod新增的func方法
	};

	return mod;
})(module1)
```

> 通过传入module1，实现对module1的继承和新增方法func，相当于创建module1子类的构造函数

**输入全局变量**

	独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。

	为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

``` js
var module1 = (function ($, YAHOO) {
	// ...
})(jQuery, YAHOO);
```

> 这里的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1模块中。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

!> 这就是JavaScript模块化开发

