<!--
 * @Description: 高性能页面滚动
 * @Date: 2019-09-02 10:38:11
 * @LastEditors: phoebus
 * @LastEditTime: 2019-09-02 12:02:21
 -->
# 高性能页面滚动

## 前言

#### 滚动优化的问题

	滚动优化问题不仅仅只是scroll 事件(滑动窗口)，更包括resize(改变窗口大小)等触发事件，包括频繁的位置计算、DOM操作、页面重绘、hover事件等问题

* 所谓的`scroll 事件`，就是滚动条滚动事件，当滚动条发生滚动的时候，`scroll事件`会被频繁的触发，当然这个也要看浏览器性能优化处理，不同浏览器之间处理方案存在不同

	* 问题也就是当页面滚动时频繁触发这类事件，将会造成页面性能大量消耗，也就会容易导致页面卡顿，影响用户体验

	* 同时主要也是页面滚动的时候，图片懒加载、下拉自动加载数据等事件因为`scroll事件`而被频繁触发，导致需要频繁的页面计算和页面重绘等操作，这些才是严重影响页面性能的问题

``` js
// 这个代码可以让我们看出页面滚动的时候scroll事件被频繁触发
var i = 0;
window.addEventListener('scroll',function(){
    console.log(i++);
}, false);
```

###### 关于页面渲染

	简单chrome浏览器的页面渲染步骤：

		JavaScript --> Style --> Layout --> Paint --> Composite

* JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。

- Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式

	* 这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。

* Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。

	* web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。
	
	* 比如，<body\> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。

* Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。

	* 一般来说，这个绘制过程是在多个层上完成的。

* Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。

	* 在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。
	
	* 对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

**大致页面渲染**

* 网页生成的时候，至少会渲染（Layout+Paint）一次

* 用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）

> 而`scroll事件`和`resize事件`如果不加限制，将会频繁的触发页面重新渲染

> 当我们滚动页面时，浏览器可能会需要绘制这些层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。显然，如果当我们滚动时，像视差网站(戳我看看)这样有东西在移动时，有可能在多层导致大面积的内容调整，这会导致大量的绘制工作

#### 解决方案

1. 降低`scroll事件`执行频率

	* 这样我们现有比较常见的解决方案是`防抖`和`节流`方案

	* 使用防抖和节流能明显降低事件触发频率，当然具体针对业务需求使用方案，甚至两种结合使用

2. 

## 防抖（Debouncing）和节流（Throttling）解决

#### 防抖(Debouncing)

	原理是延迟执行事件，规定事件时间范围内被触发的次数

* 一般使用`setTimeout`实现延迟效果

**防抖封装实现**

``` js
/* 
 * fn：回调函数，指定触发的事件
 * waitTime：指定事件触发的时间，单位毫秒
 * immediate：首次是否立即执行
 *
 */
function debounce(fn, waitTime, immediate) {
	// 声明定时器
	var timeout;
	// 闭包返回，运行重复使用
	return function() {
		// 保存上下文和参入的参数
		var context = this,
			args = arguments;
		// 定时器执行方法
		var later = function() {
			timeout = null;
			if (!immediate) {
				fn.apply(context, args);
			}
		};
		// 是否立即执行
		var callNow = immediate && !timeout;
		// 清除定时器
		clearTimeout(timeout);		
		// 设置定时器
		timeout = setTimeout(later, waitTime);
		if (callNow) {
			// 如果需要立即执行，先执行一遍
			fn.apply(context, args);
		}
	}
}

var scrollActive = debounce(function() {
	// 页面滚动时执行的回调
}, 250);

var resizeActive = debounce(function() {
	// 页面滚动时执行的回调
}, 250);


// 绑定监听
window.addEventListener('scroll', scrollActive);

window.addEventListener('resize', resizeActive);
```

> 这个防抖就是限制指定时间内不会触发两次事件

#### 节流(Throttling)




## 使用 rAF（requestAnimationFrame）触发滚动事件解决



## 使用 pointer-events: none 禁止鼠标事件

	

> [pointer-events:none提高页面滚动时候的绘制性能？](https://www.zhangxinxu.com/wordpress/2014/01/pointer-events-none-avoiding-unnecessary-paints/)

## 总结



> 参考：[【前端性能】高性能滚动 scroll 及页面渲染优化](https://www.cnblogs.com/coco1s/p/5499469.html)
